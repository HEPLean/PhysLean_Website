---
layout: default
---
<style>
  :root {
    --bg-color: #2E3440;
    --fg-color: #D8DEE9;
    --link-color: #81A1C1;
    --button-bg: #4CAF50;
    --button-text: #FFFFFF;
    --border-color: #4C566A;
    --list-bg: #3B4252;
    --list-text: #A3BE8C;
  }



  a {
    color: var(--link-color);
    text-decoration: none;
  }

  a:hover {
    text-decoration: underline;
  }

  #graph {
    border: 1px solid var(--border-color);
    border-radius: 8px;
    margin-bottom: 20px;
    background-color: #fff; /* Graph background is usually white */
  }

  ul {
    list-style-type: disc;
    padding-left: 20px;
  }

  li {
    margin-bottom: 8px;
  }

  .custom-graph-container {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
  }

  .list-container {
    flex: 1;
    min-width: 300px;
  }

  #sources-list, #targets-list {
    height: 200px;
    overflow-y: auto;
    border: 1px solid var(--border-color);
    background-color: var(--list-bg);
    color: var(--list-text);
    font-family: monospace;
    padding: 10px;
    border-radius: 8px;
    font-size: 0.9em;
  }

  #sources-list div, #targets-list div {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 2px 0;
  }

  input[type="checkbox"] {
    accent-color: var(--button-bg);
  }

  #renderBtn {
    font-size: 1.2em;
    padding: 10px 20px;
    margin-top: 1em;
    background-color: var(--button-bg);
    color: var(--button-text);
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.3s ease;
    width: 100%;
  }

  #renderBtn:hover {
    background-color: #45a049;
  }

  code {
    background-color: var(--list-bg);
    color: var(--list-text);
    padding: 2px 5px;
    border-radius: 4px;
  }
</style>

<h1>Dependencies</h1>
<!--

Veiwing the dependency graph of PhysLean

The code below reads in the file "my_graph.dot" which is generated by running 
`lake exe graph my_graph.dot` 
in the PhysLean directory. 

The display of the dot file is done via d3
-->
<!-- Downloading dj -->
<script src="//d3js.org/d3.v7.min.js"></script>
<script src="https://unpkg.com/@hpcc-js/wasm@2.20.0/dist/graphviz.umd.js"></script>
<script src="https://unpkg.com/d3-graphviz@5.6.0/build/d3-graphviz.js"></script>
<script>

  async function filterDot(dotText, sources, targets) {
    const edgeRegex = /"([^"]+)"\s*->\s*"([^"]+)"/g;
    const adj = {}, revAdj = {};
    let match;

    while ((match = edgeRegex.exec(dotText)) !== null) {
      const [_, from, to] = match;
      (adj[from] ||= new Set()).add(to);
      (revAdj[to] ||= new Set()).add(from);
    }

    function bfs(startNodes, graph) {
      const visited = new Set(startNodes);
      const queue = [...startNodes];
      while (queue.length) {
        const node = queue.shift();
        for (const next of graph[node] || []) {
          if (!visited.has(next)) {
            visited.add(next);
            queue.push(next);
          }
        }
      }
      return visited;
    }

    const forward = bfs(sources, adj);
    const backward = bfs(targets, revAdj);
    let keep = new Set([...forward].filter(n => backward.has(n)));
    console.log("Sources size:", sources.length);
    if (sources.length === 0) {
      console.log("No sources selected, using backward reachability only.");
      keep = new Set(backward);
    }

    // Filter nodes and edges
    const nodeRegex = /"([^"]+)"\s*\[.*?];/g;
    let result = 'digraph "import_graph" {\n';

    while ((match = nodeRegex.exec(dotText)) !== null) {
      const node = match[1];
      if (keep.has(node)) result += `  ${match[0]}\n`;
    }

    edgeRegex.lastIndex = 0;
    while ((match = edgeRegex.exec(dotText)) !== null) {
      const [_, from, to] = match;
      if (keep.has(from) && keep.has(to)) result += `  "${from}" -> "${to}";\n`;
    }

    result += '}';

    return result;
  }
  function renderGraph(sources, targets) {
    console.log("Rendering graph with sources:", sources, "and targets:", targets);
    fetch('./assets/my_graph.dot')
      .then(response => response.text())
      .then(dotText =>

        filterDot(
          dotText,
          sources,
          targets
        ))
      .then(filteredDot => {

        d3.select("#graph")
          .graphviz()
          .zoom(true)
          .fit(true)
          .width("100%")
          .height("500px") // Increased height for better viewing
          .renderDot(filteredDot);
      })
      .catch(error => console.error('Error fetching dot file:', error));
  }
</script>

    <!-- Container for the graph -->
    <div id="graph"></div>
    <h2>Premade graphs</h2>
    <ul> 
      <li><a
          href="./Dependencies.html?sources=&targets=PhysLean">Everything</a></li>
      <li><a href = "./Dependencies.html?sources=PhysLean.SpaceAndTime.SpaceTime.Basic,PhysLean.Mathematics.List.InsertIdx,PhysLean.Mathematics.Fin,PhysLean.QFT.PerturbationTheory.CreateAnnihilate&targets=PhysLean.QFT.PerturbationTheory.WickAlgebra.WicksTheorem">Proof of Wick's theorem</a></li>
      <li><a href = "./Dependencies.html?sources=PhysLean.SpaceAndTime.Space.Basic">Everything dependent on space-time</a></li>
      <li><a href="./Dependencies.html?sources=&targets=PhysLean.QuantumMechanics.OneDimension.HarmonicOscillator.TISE">The 1d QM harmonic oscillator</a></li>
    </ul>
    <h2>Custom graph</h2>
      <p>You can make your own custom graph by selecting sources and targets below, or 
      using the url parameters <br>
      <code>?sources=Source1,Source2&targets=Target1,Target2</code>.</p>
      
      <div class="custom-graph-container">
        <div class="list-container">
          <h3>Sources</h3>
          <div id="sources-list"></div>
        </div>
        <div class="list-container">
          <h3>Targets</h3>
          <div id="targets-list"></div>
        </div>
      </div>
    
  <button id="renderBtn">Render Graph</button>
 

<script>
  const sourcesList = document.getElementById('sources-list');
  const targetsList = document.getElementById('targets-list');
  const renderBtn = document.getElementById('renderBtn');

  function updateGraph() {
    const selectedSources = document.querySelectorAll('input[name="source-checkbox"]:checked');
    const selectedTargets = document.querySelectorAll('input[name="target-checkbox"]:checked');

    const sources = Array.from(selectedSources).map(input => input.value);
    const targets = Array.from(selectedTargets).map(input => input.value);

    console.log("Sources:", sources);
    console.log("Targets:", targets);
    if (targets.length > 0) {
      renderGraph(sources, targets);
    }
  }

  function populateLists(dotText) {
    const nodeRegex = /"([^"]+)"\s*\[/g;
    const nodes = new Set();
    let match;
    while ((match = nodeRegex.exec(dotText)) !== null) {
      nodes.add(match[1]);
    }

    const sortedNodes = Array.from(nodes).sort();

    sortedNodes.forEach(node => {
      // Create for sources list
      const sourceDiv = document.createElement('div');
      const sourceCheckbox = document.createElement('input');
      sourceCheckbox.type = 'checkbox';
      sourceCheckbox.name = 'source-checkbox';
      sourceCheckbox.value = node;
      sourceCheckbox.id = `source-${node}`;
      const sourceLabel = document.createElement('label');
      sourceLabel.htmlFor = `source-${node}`;
      sourceLabel.textContent = node;
      sourceDiv.appendChild(sourceCheckbox);
      sourceDiv.appendChild(sourceLabel);
      sourcesList.appendChild(sourceDiv);

      // Create for targets list
      const targetDiv = document.createElement('div');
      const targetCheckbox = document.createElement('input');
      targetCheckbox.type = 'checkbox';
      targetCheckbox.name = 'target-checkbox';
      targetCheckbox.value = node;
      targetCheckbox.id = `target-${node}`;
      const targetLabel = document.createElement('label');
      targetLabel.htmlFor = `target-${node}`;
      targetLabel.textContent = node;
      targetDiv.appendChild(targetCheckbox);
      targetDiv.appendChild(targetLabel);
      targetsList.appendChild(targetDiv);
    });

    // Set initial values and render
    const initialSource = "PhysLean.ClassicalMechanics.HamiltonsEquations";
    const initialTarget = "PhysLean";

    // Read initial sources and targets from URL parameters.
    // Example: ?sources=Source1,Source2&targets=Target1
    // If not provided, use the default values defined in initialSource and initialTarget.
    const urlParams = new URLSearchParams(window.location.search);
    const sourcesFromUrl = urlParams.get('sources');
    const targetsFromUrl = urlParams.get('targets');

    let sourcesToCheck = sourcesFromUrl === null ? [initialSource] : (sourcesFromUrl === "" ? [] : sourcesFromUrl.split(','));
    let targetsToCheck = targetsFromUrl === null ? [initialTarget] : (targetsFromUrl === "" ? [] : targetsFromUrl.split(','));

    if (sourcesFromUrl) {
      sourcesToCheck = sourcesFromUrl === "" ? [] : sourcesFromUrl.split(',');
    }

    if (targetsFromUrl) {
      targetsToCheck = targetsFromUrl.split(',');
    }

    sourcesToCheck.forEach(source => {
      const checkbox = document.getElementById(`source-${source}`);
      if (checkbox) checkbox.checked = true;
    });

    targetsToCheck.forEach(target => {
      const checkbox = document.getElementById(`target-${target}`);
      if (checkbox) checkbox.checked = true;
    });

    updateGraph();
  }

  // Fetch the dot file to populate the lists
  fetch('./assets/my_graph.dot')
    .then(response => response.text())
    .then(populateLists)
    .catch(error => console.error('Error fetching or parsing dot file:', error));

  renderBtn.addEventListener('click', updateGraph);
</script>