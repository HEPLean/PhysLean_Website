
title: "Proof of Wick's theorem"
curators: Joseph Tooby-Smith
parts:
  
  - type: h1
    sectionNo: 1
    content: "Introduction"

  - type: remark
    name: "wicks_theorem_context"
    status : "incomplete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/WicksTheorem.lean#L49"
    content: |
      
        In perturbative quantum field theory, Wick's theorem allows
        us to expand expectation values of time-ordered products of fields in terms of normal-orders
        and time contractions.
        The theorem is used to simplify the calculation of scattering amplitudes, and is the precurser
        to Feynman diagrams.
      
        There are actually three different versions of Wick's theorem used.
        The static version, the time-dependent version, and the normal-ordered time-dependent version.
        PhysLean contains a formalization of all three of these theorems in complete generality for
        mixtures of bosonic and fermionic fields.
      
        The statement of these theorems for bosons is simplier then when fermions are involved, since
        one does not have to worry about the minus-signs picked up on exchanging fields.

  - type: p
    content: "In this note we walk through the important parts of the proof of the three versions of
      Wick's theorem for field operators containing carrying both fermionic and bosonic statitics,
      as it appears in PhysLean. Not every lemma or definition is covered here.
      The aim is to give just enough that the story can be understood."

  - type: p
    content: "
     Before proceeding with the steps in the proof, we review some basic terminology
     related to Lean and type theory. The most important notion is that of a type.
     We don't give any formal definition here, except to say that a type `T`, like a set, has
     elements `x` which we say are of type `T` and write `x : T`. Examples of types include,
     the type of natural numbers `‚Ñï`, the type of real numbers `‚Ñù`, the type of numbers
     `0, ‚Ä¶, n-1` denoted `Fin n`. Given two types `T` and `S`, we can form the product type `T √ó S`,
     and the function type `T ‚Üí S`.

     Types form the foundation of Lean and the theory behind them will be used both explicitly and
      implicitly throughout this note."

  - type: h1
    sectionNo: 2
    content: "Field operators"

  - type: h2
    sectionNo: "2.1"
    content: "Field statistics"

  - type: name
    name: FieldStatistic
    line: 18
    fileName: PhysLean.QFT.PerturbationTheory.FieldStatistics.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldStatistics/Basic.lean#L18"
    isDef: true
    isThm: false
    docString: |
      The type `FieldStatistic` is the type containing two elements `bosonic` and `fermionic`.
      This type is used to specify if a field or operator obeys bosonic or fermionic statistics. 
    declString: |
      inductive FieldStatistic : Type where
        | bosonic : FieldStatistic
        | fermionic : FieldStatistic
      deriving DecidableEq
    declNo: "2.1"

  - type: name
    name: FieldStatistic.instCommGroup
    line: 29
    fileName: PhysLean.QFT.PerturbationTheory.FieldStatistics.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldStatistics/Basic.lean#L29"
    isDef: true
    isThm: false
    docString: |
      The type `FieldStatistic` carries an instance of a commutative group in which
      - `bosonic * bosonic = bosonic`
      - `bosonic * fermionic = fermionic`
      - `fermionic * bosonic = fermionic`
      - `fermionic * fermionic = bosonic`
      
      This group is isomorphic to `‚Ñ§‚ÇÇ`. 
    declString: |
      instance : CommGroup FieldStatistic where
        one := bosonic
        mul a b :=
          match a, b with
          | bosonic, bosonic => bosonic
          | bosonic, fermionic => fermionic
          | fermionic, bosonic => fermionic
          | fermionic, fermionic => bosonic
        inv a := a
        mul_assoc a b c := by
          cases a <;> cases b <;> cases c <;>
          dsimp [HMul.hMul]
        one_mul a := by
          cases a <;> dsimp [HMul.hMul]
        mul_one a := by
          cases a <;> dsimp [HMul.hMul]
        inv_mul_cancel a := by
          cases a <;> dsimp only [HMul.hMul, Nat.succ_eq_add_one] <;> rfl
        mul_comm a b := by
          cases a <;> cases b <;> rfl
    declNo: "2.2"

  - type: name
    name: FieldStatistic.exchangeSign
    line: 27
    fileName: PhysLean.QFT.PerturbationTheory.FieldStatistics.ExchangeSign
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldStatistics/ExchangeSign.lean#L27"
    isDef: true
    isThm: false
    docString: |
      The exchange sign, `exchangeSign`, is defined as the group homomorphism
      
      `FieldStatistic ‚Üí* FieldStatistic ‚Üí* ‚ÑÇ`,
      
      for which `exchangeSign a b` is `-1` if both `a` and `b` are `fermionic` and `1` otherwise.
      The exchange sign is the sign one picks up on exchanging an operator or field `œÜ‚ÇÅ` of statistic
      `a` with an operator or field `œÜ‚ÇÇ` of statistic `b`, i.e. `œÜ‚ÇÅœÜ‚ÇÇ ‚Üí œÜ‚ÇÇœÜ‚ÇÅ`.
      
      The notation `ùì¢(a, b)` is used for the exchange sign of `a` and `b`. 
    declString: |
      def exchangeSign : FieldStatistic ‚Üí* FieldStatistic ‚Üí* ‚ÑÇ where
        toFun a :=
          {
            toFun := fun b =>
              match a, b with
              | bosonic, _ => 1
              | _, bosonic => 1
              | fermionic, fermionic => -1
            map_one' := by
              fin_cases a
              <;> simp
            map_mul' := fun c b => by
              fin_cases a <;>
                fin_cases b <;>
                fin_cases c <;>
                simp
          }
        map_one' := by
          ext b
          fin_cases b
          <;> simp
        map_mul' c b := by
          ext a
          fin_cases a
          <;> fin_cases b <;> fin_cases c
          <;> simp
    declNo: "2.3"

  - type: h2
    sectionNo: "2.2"
    content: "Field specifications"

  - type: name
    name: FieldSpecification
    line: 32
    fileName: PhysLean.QFT.PerturbationTheory.FieldSpecification.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldSpecification/Basic.lean#L32"
    isDef: true
    isThm: false
    docString: |
      The structure `FieldSpecification` is defined to have the following content:
      - A type `Field` whose elements are the constituent fields of the theory.
      - For every field `f` in `Field`, a type `PositionLabel f` whose elements label the different
        position operators associated with the field `f`. For example,
        - For `f` a *real-scalar field*, `PositionLabel f` will have a unique element.
        - For `f` a *complex-scalar field*, `PositionLabel f` will have two elements, one for the field
          operator and one for its conjugate.
        - For `f` a *Dirac fermion*, `PositionLabel f` will have eight elements, one for each Lorentz
          index of the field and its conjugate.
        - For `f` a *Weyl fermion*, `PositionLabel f` will have four elements, one for each Lorentz
          index of the field and its conjugate.
      - For every field `f` in `Field`, a type `AsymptoticLabel f` whose elements label the different
        types of incoming asymptotic field operators associated with the
        field `f` (this also matches the types of outgoing asymptotic field operators).
        For example,
        - For `f` a *real-scalar field*, `AsymptoticLabel f` will have a unique element.
        - For `f` a *complex-scalar field*, `AsymptoticLabel f` will have two elements, one for the
          field operator and one for its conjugate.
        - For `f` a *Dirac fermion*, `AsymptoticLabel f` will have four elements, two for each spin.
        - For `f` a *Weyl fermion*, `AsymptoticLabel f` will have two elements, one for each spin.
      - For each field `f` in `Field`, a field statistic `statistic f` which classifies `f` as either
        `bosonic` or `fermionic`.
      
    declString: |
      structure FieldSpecification where
        /-- A type whose elements are the constituent fields of the theory. -/
        Field : Type
        /-- For every field `f` in `Field`, the type `PositionLabel f` has elements that label the
          different position operators associated with the field `f`. -/
        PositionLabel : Field ‚Üí Type
        /-- For every field `f` in `Field`, the type `AsymptoticLabel f` has elements that label
          the different asymptotic based field operators associated with the field `f`. -/
        AsymptoticLabel : Field ‚Üí Type
        /-- For every field `f` in `Field`, the field statistic `statistic f` classifies `f` as either
          `bosonic` or `fermionic`. -/
        statistic : Field ‚Üí FieldStatistic
    declNo: "2.4"

  - type: h2
    sectionNo: "2.3"
    content: "Field operators"

  - type: name
    name: FieldSpecification.FieldOp
    line: 72
    fileName: PhysLean.QFT.PerturbationTheory.FieldSpecification.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldSpecification/Basic.lean#L72"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, the inductive type `ùìï.FieldOp` is defined
        to contain the following elements:
      - For every `f` in `ùìï.Field`, element of `e` of `AsymptoticLabel f` and `3`-momentum `p`, an
        element labelled `inAsymp f e p` corresponding to an incoming asymptotic field operator
        of the field `f`, of label `e` (e.g. specifying the spin), and momentum `p`.
      - For every `f` in `ùìï.Field`, element of `e` of `PositionLabel f` and space-time position `x`, an
        element labelled `position f e x` corresponding to a position field operator of the field `f`,
        of label `e` (e.g. specifying the Lorentz index), and position `x`.
      - For every `f` in `ùìï.Field`, element of `e` of `AsymptoticLabel f` and `3`-momentum `p`, an
        element labelled `outAsymp f e p` corresponding to an outgoing asymptotic field operator of the
        field `f`, of label `e` (e.g. specifying the spin), and momentum `p`.
      
      As an example, if `f` corresponds to a Weyl-fermion field, then
      - For `inAsymp f e p`, `e` would correspond to a spin `s`, and `inAsymp f e p` would, once
        represented in the operator algebra,
        be proportional to the creation operator `a(p, s)`.
      - `position f e x`, `e` would correspond to a Lorentz index `a`, and `position f e x` would,
        once represented in the operator algebra, be proportional to the operator
      
        `‚àë s, ‚à´ d¬≥p/(‚Ä¶) (x‚Çê(p,s) a(p, s) e ^ (-i p x) + y‚Çê(p,s) a‚Ä†(p, s) e ^ (-i p x))`.
      
      - `outAsymp f e p`, `e` would correspond to a spin `s`, and `outAsymp f e p` would,
        once represented in the operator algebra, be proportional to the
        annihilation operator `a‚Ä†(p, s)`.
      
      
    declString: |
      inductive FieldOp (ùìï : FieldSpecification) where
        | inAsymp : (Œ£ f, ùìï.AsymptoticLabel f) √ó (Fin 3 ‚Üí ‚Ñù) ‚Üí ùìï.FieldOp
        | position : (Œ£ f, ùìï.PositionLabel f) √ó SpaceTime ‚Üí ùìï.FieldOp
        | outAsymp : (Œ£ f, ùìï.AsymptoticLabel f) √ó (Fin 3 ‚Üí ‚Ñù) ‚Üí ùìï.FieldOp
    declNo: "2.5"

  - type: name
    name: FieldSpecification.fieldOpStatistic
    line: 115
    fileName: PhysLean.QFT.PerturbationTheory.FieldSpecification.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldSpecification/Basic.lean#L115"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, and an element `œÜ` of `ùìï.FieldOp`.
        The field statistic `fieldOpStatistic œÜ` is defined to be the statistic associated with
        the field underlying `œÜ`.
      
        The following notation is used in relation to `fieldOpStatistic`:
      - For `œÜ` an element of `ùìï.FieldOp`, `ùìï |>‚Çõ œÜ` is `fieldOpStatistic œÜ`.
      - For `œÜs` a list of `ùìï.FieldOp`, `ùìï |>‚Çõ œÜs` is the product of `fieldOpStatistic œÜ` over
        the list `œÜs`.
      - For a function `f : Fin n ‚Üí ùìï.FieldOp` and a finite set `a` of `Fin n`, `ùìï |>‚Çõ ‚ü®f, a‚ü©` is the
        product of `fieldOpStatistic (f i)` for all `i ‚àà a`. 
    declString: |
      def fieldOpStatistic : ùìï.FieldOp ‚Üí FieldStatistic := ùìï.statistic ‚àò ùìï.fieldOpToField
    declNo: "2.6"

  - type: name
    name: CreateAnnihilate
    line: 14
    fileName: PhysLean.QFT.PerturbationTheory.CreateAnnihilate
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/CreateAnnihilate.lean#L14"
    isDef: true
    isThm: false
    docString: |
      The type `CreateAnnihilate` is the type containing two elements `create` and `annihilate`.
      This type is used to specify if an operator is a creation, or annihilation, operator
      or the sum thereof or integral thereover etc. 
    declString: |
      inductive CreateAnnihilate where
        | create : CreateAnnihilate
        | annihilate : CreateAnnihilate
      deriving Inhabited, BEq, DecidableEq
    declNo: "2.7"

  - type: name
    name: FieldSpecification.CrAnFieldOp
    line: 65
    fileName: PhysLean.QFT.PerturbationTheory.FieldSpecification.CrAnFieldOp
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldSpecification/CrAnFieldOp.lean#L65"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, the (sigma) type `ùìï.CrAnFieldOp`
      corresponds to the type of creation and annihilation parts of field operators.
      It formally defined to consist of the following elements:
      - For each incoming asymptotic field operator `œÜ` in `ùìï.FieldOp` an element
        written as `‚ü®œÜ, ()‚ü©` in `ùìï.CrAnFieldOp`, corresponding to the creation part of `œÜ`.
        Here `œÜ` has no annihilation part. (Here `()` is the unique element of `Unit`.)
      - For each position field operator `œÜ` in `ùìï.FieldOp` an element of `ùìï.CrAnFieldOp`
        written as `‚ü®œÜ, .create‚ü©`, corresponding to the creation part of `œÜ`.
      - For each position field operator `œÜ` in `ùìï.FieldOp` an element of `ùìï.CrAnFieldOp`
        written as `‚ü®œÜ, .annihilate‚ü©`, corresponding to the annihilation part of `œÜ`.
      - For each outgoing asymptotic field operator `œÜ` in `ùìï.FieldOp` an element
        written as `‚ü®œÜ, ()‚ü©` in `ùìï.CrAnFieldOp`, corresponding to the annihilation part of `œÜ`.
        Here `œÜ` has no creation part. (Here `()` is the unique element of `Unit`.)
      
      As an example, if `f` corresponds to a Weyl-fermion field, it would contribute
        the following elements to `ùìï.CrAnFieldOp`
      - For each spin `s`, an element corresponding to an incoming asymptotic operator: `a(p, s)`.
      - For each each Lorentz
        index `a`, an element corresponding to the creation part of a position operator:
      
        `‚àë s, ‚à´ d¬≥p/(‚Ä¶) (x‚Çê (p,s) a(p, s) e ^ (-i p x))`.
      - For each each Lorentz
        index `a`,an element corresponding to annihilation part of a position operator:
      
        `‚àë s, ‚à´ d¬≥p/(‚Ä¶) (y‚Çê(p,s) a‚Ä†(p, s) e ^ (-i p x))`.
      - For each spin `s`, element corresponding to an outgoing asymptotic operator: `a‚Ä†(p, s)`.
      
      
    declString: |
      def CrAnFieldOp : Type := Œ£ (s : ùìï.FieldOp), ùìï.fieldOpToCrAnType s
    declNo: "2.8"

  - type: name
    name: FieldSpecification.crAnFieldOpToCreateAnnihilate
    line: 103
    fileName: PhysLean.QFT.PerturbationTheory.FieldSpecification.CrAnFieldOp
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldSpecification/CrAnFieldOp.lean#L103"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, `ùìï.crAnFieldOpToCreateAnnihilate` is the map from
        `ùìï.CrAnFieldOp` to `CreateAnnihilate` taking `œÜ` to `create` if
      - `œÜ` corresponds to an incoming asymptotic field operator or the creation part of a position based
        field operator.
      
      otherwise it takes `œÜ` to `annihilate`.
      
    declString: |
      def crAnFieldOpToCreateAnnihilate : ùìï.CrAnFieldOp ‚Üí CreateAnnihilate
        | ‚ü®FieldOp.inAsymp _, _‚ü© => CreateAnnihilate.create
        | ‚ü®FieldOp.position _, CreateAnnihilate.create‚ü© => CreateAnnihilate.create
        | ‚ü®FieldOp.position _, CreateAnnihilate.annihilate‚ü© => CreateAnnihilate.annihilate
        | ‚ü®FieldOp.outAsymp _, _‚ü© => CreateAnnihilate.annihilate
    declNo: "2.9"

  - type: name
    name: FieldSpecification.crAnStatistics
    line: 116
    fileName: PhysLean.QFT.PerturbationTheory.FieldSpecification.CrAnFieldOp
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldSpecification/CrAnFieldOp.lean#L116"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, and an element `œÜ` in `ùìï.CrAnFieldOp`, the field
      statistic `crAnStatistics œÜ` is defined to be the statistic associated with the field `ùìï.Field`
      (or the `ùìï.FieldOp`) underlying `œÜ`.
      
      The following notation is used in relation to `crAnStatistics`:
      - For `œÜ` an element of `ùìï.CrAnFieldOp`, `ùìï |>‚Çõ œÜ` is `crAnStatistics œÜ`.
      - For `œÜs` a list of `ùìï.CrAnFieldOp`, `ùìï |>‚Çõ œÜs` is the product of `crAnStatistics œÜ` over
        the list `œÜs`.
      
    declString: |
      def crAnStatistics : ùìï.CrAnFieldOp ‚Üí FieldStatistic :=
        ùìï.fieldOpStatistic ‚àò ùìï.crAnFieldOpToFieldOp
    declNo: "2.10"

  - type: remark
    name: "notation_remark"
    status : "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldSpecification/CrAnFieldOp.lean#L141"
    content: |
      When working with a field specification `ùìï` the
      following notation will be used within doc-strings:
      - when field statistics occur in exchange signs the `ùìï |>‚Çõ _` may be dropped.
      - lists of `FieldOp` or `CrAnFieldOp` `œÜs` may be written as `œÜ‚ÇÄ‚Ä¶œÜ‚Çô`,
        which should be interpreted within the context in which it appears.
      - `œÜ·∂ú` may be used to indicate the creation part of an operator and
        `œÜ·µÉ` to indicate the annihilation part of an operator.
      
      Some examples of these notation-conventions are:
      - `ùì¢(œÜ, œÜs)` which corresponds to `ùì¢(ùìï |>‚Çõ œÜ, ùìï |>‚Çõ œÜs)`
      - `œÜ‚ÇÄ‚Ä¶œÜ·µ¢‚Çã‚ÇÅœÜ·µ¢‚Çä‚ÇÅ‚Ä¶œÜ‚Çô` which corresponds to a (given) list `œÜs = œÜ‚ÇÄ‚Ä¶œÜ‚Çô` with the element at the
        `i`th position removed.
      

  - type: h2
    sectionNo: "2.4"
    content: "Field-operator free algebra"

  - type: name
    name: FieldSpecification.FieldOpFreeAlgebra
    line: 37
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpFreeAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpFreeAlgebra/Basic.lean#L37"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, the algebra `ùìï.FieldOpFreeAlgebra` is
      the free algebra generated by `ùìï.CrAnFieldOp`. 
    declString: |
      abbrev FieldOpFreeAlgebra (ùìï : FieldSpecification) : Type := FreeAlgebra ‚ÑÇ ùìï.CrAnFieldOp
    declNo: "2.11"

  - type: remark
    name: "naming_convention"
    status : "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpFreeAlgebra/Basic.lean#L43"
    content: |
      
        For mathematicial objects defined in relation to `FieldOpFreeAlgebra` the postfix `F`
        may be given to
        their names to indicate that they are related to the free algebra.
        This is to avoid confusion when working within the context of `FieldOpAlgebra` which is defined
        as a quotient of `FieldOpFreeAlgebra`.

  - type: name
    name: FieldSpecification.FieldOpFreeAlgebra.ofCrAnOpF
    line: 50
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpFreeAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpFreeAlgebra/Basic.lean#L50"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, and a element `œÜ` of `ùìï.CrAnFieldOp`,
      `ofCrAnOpF œÜ` is defined as the element of `ùìï.FieldOpFreeAlgebra` formed by `œÜ`. 
    declString: |
      def ofCrAnOpF (œÜ : ùìï.CrAnFieldOp) : FieldOpFreeAlgebra ùìï :=
        FreeAlgebra.Œπ ‚ÑÇ œÜ
    declNo: "2.12"

  - type: name
    name: FieldSpecification.FieldOpFreeAlgebra.universality
    line: 55
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpFreeAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpFreeAlgebra/Basic.lean#L55"
    isDef: false
    isThm: false
    docString: |
      The algebra `ùìï.FieldOpFreeAlgebra` satisfies the universal property that for any other algebra
      `A` (e.g. the operator algebra of the theory) with a map `f : ùìï.CrAnFieldOp ‚Üí A` (e.g.
      the inclusion of the creation and annihilation parts of field operators into the
      operator algebra) there is a unique algebra map `g : ùìï.FieldOpFreeAlgebra ‚Üí A`
      such that `g ‚àò ofCrAnOpF = f`.
      
      The unique `g` is given by `FreeAlgebra.lift ‚ÑÇ f`.
      
    declString: |
      lemma universality {A : Type} [Semiring A] [Algebra ‚ÑÇ A] (f : ùìï.CrAnFieldOp ‚Üí A) :
          ‚àÉ! g : FieldOpFreeAlgebra ùìï ‚Üí‚Çê[‚ÑÇ] A, g ‚àò ofCrAnOpF = f := by
        use FreeAlgebra.lift ‚ÑÇ f
        apply And.intro
        ¬∑ funext x
          simp [ofCrAnOpF]
        ¬∑ intro g hg
          ext x
          simpa using congrFun hg x
    declNo: "2.13"

  - type: name
    name: FieldSpecification.FieldOpFreeAlgebra.ofCrAnListF
    line: 74
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpFreeAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpFreeAlgebra/Basic.lean#L74"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, and a list `œÜs` of `ùìï.CrAnFieldOp`,
      `ofCrAnListF œÜs` is defined as the element of `ùìï.FieldOpFreeAlgebra`
      obtained by the product of `ofCrAnListF œÜ` for each `œÜ` in `œÜs`.
      For example `ofCrAnListF [œÜ‚ÇÅ, œÜ‚ÇÇ, œÜ‚ÇÉ] = ofCrAnOpF œÜ‚ÇÅ * ofCrAnOpF œÜ‚ÇÇ * ofCrAnOpF œÜ‚ÇÉ`.
      The set of all `ofCrAnListF œÜs` forms a basis of `FieldOpFreeAlgebra ùìï`. 
    declString: |
      def ofCrAnListF (œÜs : List ùìï.CrAnFieldOp) : FieldOpFreeAlgebra ùìï := (List.map ofCrAnOpF œÜs).prod
    declNo: "2.14"

  - type: name
    name: FieldSpecification.FieldOpFreeAlgebra.ofFieldOpF
    line: 94
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpFreeAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpFreeAlgebra/Basic.lean#L94"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, and an element `œÜ` of `ùìï.FieldOp`,
      `ofFieldOpF œÜ` is the element of `ùìï.FieldOpFreeAlgebra` formed by summing over
      `ofCrAnOpF` of the
      creation and annihilation parts of `œÜ`.
      
      For example, for `œÜ` an incoming asymptotic field operator we get
      `ofCrAnOpF ‚ü®œÜ, ()‚ü©`, and for `œÜ` a
      position field operator we get `ofCrAnOpF ‚ü®œÜ, .create‚ü© + ofCrAnOpF ‚ü®œÜ, .annihilate‚ü©`. 
    declString: |
      def ofFieldOpF (œÜ : ùìï.FieldOp) : FieldOpFreeAlgebra ùìï :=
        ‚àë (i : ùìï.fieldOpToCrAnType œÜ), ofCrAnOpF ‚ü®œÜ, i‚ü©
    declNo: "2.15"

  - type: name
    name: FieldSpecification.FieldOpFreeAlgebra.ofFieldOpListF
    line: 105
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpFreeAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpFreeAlgebra/Basic.lean#L105"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, and a list `œÜs` of `ùìï.FieldOp`,
      `ùìï.ofFieldOpListF œÜs` is defined as the element of `ùìï.FieldOpFreeAlgebra`
      obtained by the product of `ofFieldOpF œÜ` for each `œÜ` in `œÜs`.
      For example `ofFieldOpListF [œÜ‚ÇÅ, œÜ‚ÇÇ, œÜ‚ÇÉ] = ofFieldOpF œÜ‚ÇÅ * ofFieldOpF œÜ‚ÇÇ * ofFieldOpF œÜ‚ÇÉ`. 
    declString: |
      def ofFieldOpListF (œÜs : List ùìï.FieldOp) : FieldOpFreeAlgebra ùìï := (List.map ofFieldOpF œÜs).prod
    declNo: "2.16"

  - type: remark
    name: "notation_drop"
    status : "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpFreeAlgebra/Basic.lean#L111"
    content: |
      In doc-strings explicit applications of `ofCrAnOpF`,
      `ofCrAnListF`, `ofFieldOpF`, and `ofFieldOpListF` will often be dropped.

  - type: name
    name: FieldSpecification.FieldOpFreeAlgebra.fieldOpFreeAlgebraGrade
    line: 239
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpFreeAlgebra.Grading
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpFreeAlgebra/Grading.lean#L239"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, the algebra `ùìï.FieldOpFreeAlgebra` is graded by `FieldStatistic`.
      Those `ofCrAnListF œÜs` for which `œÜs` has an overall `bosonic` statistic
      (i.e. `ùìï |>‚Çõ œÜs = bosonic`) span `bosonic`
      submodule, whilst those `ofCrAnListF œÜs` for which `œÜs` has an overall `fermionic` statistic
      (i.e. `ùìï |>‚Çõ œÜs = fermionic`) span
      the `fermionic` submodule. 
    declString: |
      instance fieldOpFreeAlgebraGrade :
          GradedAlgebra (A := ùìï.FieldOpFreeAlgebra) statisticSubmodule where
        one_mem := by
          simp only [statisticSubmodule]
          refine Submodule.mem_span.mpr fun p a => a ?_
          simp only [Set.mem_setOf_eq]
          use []
          simp only [ofCrAnListF_nil, ofList_empty, true_and]
          rfl
        mul_mem f1 f2 a1 a2 h1 h2 := by
          let p (a2 : ùìï.FieldOpFreeAlgebra) (hx : a2 ‚àà statisticSubmodule f2) : Prop :=
            a1 * a2 ‚àà statisticSubmodule (f1 + f2)
          change p a2 h2
          apply Submodule.span_induction (p := p)
          ¬∑ intro x hx
            simp only [Set.mem_setOf_eq] at hx
            obtain ‚ü®œÜs, rfl, h‚ü© := hx
            simp only [p]
            let p (a1 : ùìï.FieldOpFreeAlgebra) (hx : a1 ‚àà statisticSubmodule f1) : Prop :=
              a1 * ofCrAnListF œÜs ‚àà statisticSubmodule (f1 + f2)
            change p a1 h1
            apply Submodule.span_induction (p := p)
            ¬∑ intro y hy
              obtain ‚ü®œÜs', rfl, h'‚ü© := hy
              simp only [p]
              rw [‚Üê ofCrAnListF_append]
              refine Submodule.mem_span.mpr fun p a => a ?_
              simp only [Set.mem_setOf_eq]
              use œÜs' ++ œÜs
              simp only [ofList_append, h', h, true_and]
              cases f1 <;> cases f2 <;> rfl
            ¬∑ simp [p]
            ¬∑ intro x y hx hy hx1 hx2
              simp only [add_mul, p]
              exact Submodule.add_mem _ hx1 hx2
            ¬∑ intro c a hx h1
              simp only [Algebra.smul_mul_assoc, p]
              exact Submodule.smul_mem _ _ h1
            ¬∑ exact h1
          ¬∑ simp [p]
          ¬∑ intro x y hx hy hx1 hx2
            simp only [mul_add, p]
            exact Submodule.add_mem _ hx1 hx2
          ¬∑ intro c a hx h1
            simp only [Algebra.mul_smul_comm, p]
            exact Submodule.smul_mem _ _ h1
          ¬∑ exact h2
        decompose' a := DirectSum.of (fun i => (statisticSubmodule (ùìï := ùìï) i)) bosonic (bosonicProjF a)
          + DirectSum.of (fun i => (statisticSubmodule (ùìï := ùìï) i)) fermionic (fermionicProjF a)
        left_inv a := by
          trans a.bosonicProjF + fermionicProjF a
          ¬∑ simp
          ¬∑ exact bosonicProjF_add_fermionicProjF a
        right_inv a := by
          rw [coeAddMonoidHom_apply_eq_bosonic_plus_fermionic]
          simp only [DFinsupp.toFun_eq_coe, map_add, bosonicProjF_of_bonosic_part,
            bosonicProjF_of_fermionic_part, add_zero, fermionicProjF_of_bosonic_part,
            fermionicProjF_of_fermionic_part, zero_add]
          conv_rhs => rw [directSum_eq_bosonic_plus_fermionic a]
    declNo: "2.17"

  - type: name
    name: FieldSpecification.FieldOpFreeAlgebra.superCommuteF
    line: 26
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpFreeAlgebra/SuperCommute.lean#L26"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, the super commutator `superCommuteF` is defined as the linear
      map `ùìï.FieldOpFreeAlgebra ‚Üí‚Çó[‚ÑÇ] ùìï.FieldOpFreeAlgebra ‚Üí‚Çó[‚ÑÇ] ùìï.FieldOpFreeAlgebra`
      which on the lists `œÜs` and `œÜs'` of `ùìï.CrAnFieldOp` gives
      
      `superCommuteF œÜs œÜs' = œÜs * œÜs' - ùì¢(œÜs, œÜs') ‚Ä¢ œÜs' * œÜs`.
      
      The notation `[a, b]‚ÇõF` can be used for `superCommuteF a b`. 
    declString: |
      noncomputable def superCommuteF : ùìï.FieldOpFreeAlgebra ‚Üí‚Çó[‚ÑÇ] ùìï.FieldOpFreeAlgebra ‚Üí‚Çó[‚ÑÇ]
          ùìï.FieldOpFreeAlgebra :=
        Basis.constr ofCrAnListFBasis ‚ÑÇ fun œÜs =>
        Basis.constr ofCrAnListFBasis ‚ÑÇ fun œÜs' =>
        ofCrAnListF (œÜs ++ œÜs') - ùì¢(ùìï |>‚Çõ œÜs, ùìï |>‚Çõ œÜs') ‚Ä¢ ofCrAnListF (œÜs' ++ œÜs)
    declNo: "2.18"

  - type: name
    name: FieldSpecification.FieldOpFreeAlgebra.superCommuteF_ofCrAnListF_ofCrAnListF_eq_sum
    line: 408
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpFreeAlgebra.SuperCommute
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpFreeAlgebra/SuperCommute.lean#L408"
    isDef: false
    isThm: false
    docString: |
      For a field specification `ùìï`, and two lists `œÜs = œÜ‚ÇÄ‚Ä¶œÜ‚Çô` and `œÜs'` of `ùìï.CrAnFieldOp`
      the following super commutation relation holds:
      
      `[œÜs', œÜ‚ÇÄ‚Ä¶œÜ‚Çô]‚ÇõF = ‚àë i, ùì¢(œÜs', œÜ‚ÇÄ‚Ä¶œÜ·µ¢‚Çã‚ÇÅ) ‚Ä¢ œÜ‚ÇÄ‚Ä¶œÜ·µ¢‚Çã‚ÇÅ * [œÜs', œÜ·µ¢]‚ÇõF * œÜ·µ¢‚Çä‚ÇÅ ‚Ä¶ œÜ‚Çô`
      
      The proof of this relation is via induction on the length of `œÜs`.
      
    declString: |
      lemma superCommuteF_ofCrAnListF_ofCrAnListF_eq_sum (œÜs : List ùìï.CrAnFieldOp) :
          (œÜs' : List ùìï.CrAnFieldOp) ‚Üí [ofCrAnListF œÜs, ofCrAnListF œÜs']‚ÇõF =
          ‚àë (n : Fin œÜs'.length), ùì¢(ùìï |>‚Çõ œÜs, ùìï |>‚Çõ œÜs'.take n) ‚Ä¢
          ofCrAnListF (œÜs'.take n) * [ofCrAnListF œÜs, ofCrAnOpF (œÜs'.get n)]‚ÇõF *
          ofCrAnListF (œÜs'.drop (n + 1))
        | [] => by
          simp [‚Üê ofCrAnListF_nil, superCommuteF_ofCrAnListF_ofCrAnListF]
        | œÜ :: œÜs' => by
          rw [superCommuteF_ofCrAnListF_ofCrAnListF_cons,
            superCommuteF_ofCrAnListF_ofCrAnListF_eq_sum œÜs œÜs']
          conv_rhs => erw [Fin.sum_univ_succ]
          congr 1
          ¬∑ simp
          ¬∑ simp [Finset.mul_sum, smul_smul, ofCrAnListF_cons, mul_assoc,
              FieldStatistic.ofList_cons_eq_mul, mul_comm]
    declNo: "2.19"

  - type: h2
    sectionNo: "2.5"
    content: "Field-operator algebra"

  - type: name
    name: FieldSpecification.FieldOpAlgebra
    line: 35
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/Basic.lean#L35"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, the algebra `ùìï.FieldOpAlgebra` is defined as the quotient
        of the free algebra `ùìï.FieldOpFreeAlgebra` by the ideal generated by
      - `[ofCrAnOpF œÜc, ofCrAnOpF œÜc']‚ÇõF` for `œÜc` and `œÜc'` field creation operators.
        This corresponds to the condition that two creation operators always super-commute.
      - `[ofCrAnOpF œÜa, ofCrAnOpF œÜa']‚ÇõF` for `œÜa` and `œÜa'` field annihilation operators.
        This corresponds to the condition that two annihilation operators always super-commute.
      - `[ofCrAnOpF œÜ, ofCrAnOpF œÜ']‚ÇõF` for `œÜ` and `œÜ'` operators with different statistics.
        This corresponds to the condition that two operators with different statistics always
        super-commute. In other words, fermions and bosons always super-commute.
      - `[ofCrAnOpF œÜ1, [ofCrAnOpF œÜ2, ofCrAnOpF œÜ3]‚ÇõF]‚ÇõF`. This corresponds to the condition,
        when combined with the conditions above, that the super-commutator is in the center
        of the algebra.
      
    declString: |
      abbrev FieldOpAlgebra : Type := (TwoSidedIdeal.span ùìï.fieldOpIdealSet).ringCon.Quotient
    declNo: "2.20"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.Œπ
    line: 73
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/Basic.lean#L73"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, `Œπ` is defined as the projection
      
      `ùìï.FieldOpFreeAlgebra ‚Üí‚Çê[‚ÑÇ] ùìï.FieldOpAlgebra`
      
      taking each element of `ùìï.FieldOpFreeAlgebra` to its equivalence class in `FieldOpAlgebra ùìï`. 
    declString: |
      def Œπ : FieldOpFreeAlgebra ùìï ‚Üí‚Çê[‚ÑÇ] FieldOpAlgebra ùìï where
        toFun := (TwoSidedIdeal.span ùìï.fieldOpIdealSet).ringCon.mk'
        map_one' := by rfl
        map_mul' x y := by rfl
        map_zero' := by rfl
        map_add' x y := by rfl
        commutes' x := by rfl
    declNo: "2.21"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.universality
    line: 77
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.Universality
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/Universality.lean#L77"
    isDef: false
    isThm: false
    docString: |
      For a field specification, `ùìï`, the algebra `ùìï.FieldOpAlgebra` satisfies the following universal
      property. Let `f : ùìï.CrAnFieldOp ‚Üí A` be a function and `g : ùìï.FieldOpFreeAlgebra ‚Üí‚Çê[‚ÑÇ] A`
      the universal lift of that function associated with the free algebra `ùìï.FieldOpFreeAlgebra`.
      If `g` is zero on the ideal defining `ùìï.FieldOpAlgebra`, then there exists
      algebra map `g' : FieldOpAlgebra ùìï ‚Üí‚Çê[‚ÑÇ] A` such that `g' ‚àò Œπ = g`, and furthermore this
      algebra map is unique.
      
    declString: |
      lemma universality {A : Type} [Semiring A] [Algebra ‚ÑÇ A] (f : ùìï.CrAnFieldOp ‚Üí A)
          (h1 : ‚àÄ a ‚àà TwoSidedIdeal.span ùìï.fieldOpIdealSet, FreeAlgebra.lift ‚ÑÇ f a = 0) :
          ‚àÉ! g : FieldOpAlgebra ùìï ‚Üí‚Çê[‚ÑÇ] A, g ‚àò Œπ = FreeAlgebra.lift ‚ÑÇ f := by
        use universalLift f h1
        simp only
        apply And.intro
        ¬∑ ext a
          simp
        ¬∑ intro g hg
          ext a
          obtain ‚ü®a, rfl‚ü© := Œπ_surjective a
          simpa using congrFun hg a
    declNo: "2.22"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.ofCrAnOp
    line: 495
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/Basic.lean#L495"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï` and an element `œÜ` of `ùìï.CrAnFieldOp`,
      `ofCrAnOp œÜ` is defined as the element of
      `ùìï.FieldOpAlgebra` given by `Œπ (ofCrAnOpF œÜ)`. 
    declString: |
      def ofCrAnOp (œÜ : ùìï.CrAnFieldOp) : ùìï.FieldOpAlgebra := Œπ (ofCrAnOpF œÜ)
    declNo: "2.23"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.ofCrAnList
    line: 509
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/Basic.lean#L509"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï` and a list `œÜs` of `ùìï.CrAnFieldOp`,
      `ofCrAnList œÜs` is defined as the element of
      `ùìï.FieldOpAlgebra` given by `Œπ (ofCrAnListF œÜ)`. 
    declString: |
      def ofCrAnList (œÜs : List ùìï.CrAnFieldOp) : ùìï.FieldOpAlgebra := Œπ (ofCrAnListF œÜs)
    declNo: "2.24"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.ofFieldOp
    line: 463
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/Basic.lean#L463"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï` and an element `œÜ` of `ùìï.FieldOp`,
      `ofFieldOp œÜ` is defined as the element of
      `ùìï.FieldOpAlgebra` given by `Œπ (ofFieldOpF œÜ)`. 
    declString: |
      def ofFieldOp (œÜ : ùìï.FieldOp) : ùìï.FieldOpAlgebra := Œπ (ofFieldOpF œÜ)
    declNo: "2.25"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.ofCrAnList
    line: 509
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/Basic.lean#L509"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï` and a list `œÜs` of `ùìï.CrAnFieldOp`,
      `ofCrAnList œÜs` is defined as the element of
      `ùìï.FieldOpAlgebra` given by `Œπ (ofCrAnListF œÜ)`. 
    declString: |
      def ofCrAnList (œÜs : List ùìï.CrAnFieldOp) : ùìï.FieldOpAlgebra := Œπ (ofCrAnListF œÜs)
    declNo: "2.26"

  - type: remark
    name: "notation_drop"
    status : "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/Basic.lean#L533"
    content: |
      In doc-strings we will often drop explicit applications of `ofCrAnOp`,
      `ofCrAnList`, `ofFieldOp`, and `ofFieldOpList`

  - type: name
    name: FieldSpecification.FieldOpAlgebra.anPart
    line: 536
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/Basic.lean#L536"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, and an element `œÜ` of `ùìï.FieldOp`, the
        annihilation part of `ùìï.FieldOp` as an element of `ùìï.FieldOpAlgebra`.
        Thus for `œÜ`
      - an incoming asymptotic state this is `0`.
      - a position based state this is `ofCrAnOp ‚ü®œÜ, .create‚ü©`.
      - an outgoing asymptotic state this is `ofCrAnOp ‚ü®œÜ, ()‚ü©`. 
    declString: |
      def anPart (œÜ : ùìï.FieldOp) : ùìï.FieldOpAlgebra := Œπ (anPartF œÜ)
    declNo: "2.27"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.crPart
    line: 562
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/Basic.lean#L562"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, and an element `œÜ` of `ùìï.FieldOp`, the
        creation part of `ùìï.FieldOp` as an element of `ùìï.FieldOpAlgebra`.
        Thus for `œÜ`
      - an incoming asymptotic state this is `ofCrAnOp ‚ü®œÜ, ()‚ü©`.
      - a position based state this is `ofCrAnOp ‚ü®œÜ, .create‚ü©`.
      - an outgoing asymptotic state this is `0`. 
    declString: |
      def crPart (œÜ : ùìï.FieldOp) : ùìï.FieldOpAlgebra := Œπ (crPartF œÜ)
    declNo: "2.28"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.ofFieldOp_eq_crPart_add_anPart
    line: 588
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/Basic.lean#L588"
    isDef: false
    isThm: false
    docString: |
      For field specification `ùìï`, and an element `œÜ` of `ùìï.FieldOp` the following relation holds:
      
      `ofFieldOp œÜ = crPart œÜ + anPart œÜ`
      
      That is, every field operator splits into its creation part plus its annihilation part.
      
    declString: |
      lemma ofFieldOp_eq_crPart_add_anPart (œÜ : ùìï.FieldOp) :
          ofFieldOp œÜ = crPart œÜ + anPart œÜ := by
        rw [ofFieldOp, crPart, anPart, ofFieldOpF_eq_crPartF_add_anPartF]
        simp only [map_add]
    declNo: "2.29"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.fieldOpAlgebraGrade
    line: 386
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.Grading
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/Grading.lean#L386"
    isDef: true
    isThm: false
    docString: |
      For a field statistic `ùìï`, the algebra `ùìï.FieldOpAlgebra` is graded by `FieldStatistic`.
      Those `ofCrAnList œÜs` for which `œÜs` has an overall `bosonic` statistic
      (i.e. `ùìï |>‚Çõ œÜs = bosonic`) span `bosonic`
      submodule, whilst those `ofCrAnList œÜs` for which `œÜs` has an overall `fermionic` statistic
      (i.e. `ùìï |>‚Çõ œÜs = fermionic`) span the `fermionic` submodule. 
    declString: |
      instance fieldOpAlgebraGrade : GradedAlgebra (A := ùìï.FieldOpAlgebra) statSubmodule where
        one_mem := by
          simp only [statSubmodule]
          refine Submodule.mem_span.mpr fun p a => a ?_
          simp only [Set.mem_setOf_eq]
          use []
          simp only [ofCrAnList, ofCrAnListF_nil, map_one, ofList_empty, true_and]
          rfl
        mul_mem f1 f2 a1 a2 h1 h2 := by
          let p (a2 : ùìï.FieldOpAlgebra) (hx : a2 ‚àà statSubmodule f2) : Prop :=
            a1 * a2 ‚àà statSubmodule (f1 + f2)
          change p a2 h2
          apply Submodule.span_induction
          ¬∑ intro x hx
            simp only [Set.mem_setOf_eq] at hx
            obtain ‚ü®œÜs, rfl, h‚ü© := hx
            simp only [p]
            let p (a1 : ùìï.FieldOpAlgebra) (hx : a1 ‚àà statSubmodule f1) : Prop :=
              a1 * ofCrAnList œÜs ‚àà statSubmodule (f1 + f2)
            change p a1 h1
            apply Submodule.span_induction (p := p)
            ¬∑ intro y hy
              obtain ‚ü®œÜs', rfl, h'‚ü© := hy
              simp only [p]
              rw [‚Üê ofCrAnList_append]
              refine Submodule.mem_span.mpr fun p a => a ?_
              simp only [Set.mem_setOf_eq]
              use œÜs' ++ œÜs
              simp only [ofList_append, h', h, true_and]
              cases f1 <;> cases f2 <;> rfl
            ¬∑ simp [p]
            ¬∑ intro x y hx hy hx1 hx2
              simp only [add_mul, p]
              exact Submodule.add_mem _ hx1 hx2
            ¬∑ intro c a hx h1
              simp only [Algebra.smul_mul_assoc, p]
              exact Submodule.smul_mem _ _ h1
            ¬∑ exact h1
          ¬∑ simp [p]
          ¬∑ intro x y hx hy hx1 hx2
            simp only [mul_add, p]
            exact Submodule.add_mem _ hx1 hx2
          ¬∑ intro c a hx h1
            simp only [Algebra.mul_smul_comm, p]
            exact Submodule.smul_mem _ _ h1
        decompose' a := DirectSum.of (fun i => (statSubmodule (ùìï := ùìï) i)) bosonic (bosonicProj a)
          + DirectSum.of (fun i => (statSubmodule (ùìï := ùìï) i)) fermionic (fermionicProj a)
        left_inv a := by
          trans a.bosonicProj + a.fermionicProj
          ¬∑ simp
          ¬∑ exact bosonicProj_add_fermionicProj a
        right_inv a := by
          rw [coeAddMonoidHom_apply_eq_bosonic_plus_fermionic]
          simp only [DFinsupp.toFun_eq_coe, map_add, bosonicProj_of_bosonic_part,
            bosonicProj_of_fermionic_part, add_zero, fermionicProj_of_bosonic_part,
            fermionicProj_of_fermionic_part, zero_add]
          conv_rhs => rw [directSum_eq_bosonic_plus_fermionic a]
    declNo: "2.30"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.superCommute
    line: 91
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.SuperCommute
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/SuperCommute.lean#L91"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, `superCommute` is the linear map
      
      `FieldOpAlgebra ùìï ‚Üí‚Çó[‚ÑÇ] FieldOpAlgebra ùìï ‚Üí‚Çó[‚ÑÇ] FieldOpAlgebra ùìï`
      
      defined as the descent of `Œπ ‚àò superCommuteF` in both arguments.
      In particular for `œÜs` and `œÜs'` lists of `ùìï.CrAnFieldOp` in `FieldOpAlgebra ùìï` the following
      relation holds:
      
      `superCommute œÜs œÜs' = œÜs * œÜs' - ùì¢(œÜs, œÜs') ‚Ä¢ œÜs' * œÜs`
      
      The notation `[a, b]‚Çõ` is used for `superCommute a b`.
      
    declString: |
      noncomputable def superCommute : FieldOpAlgebra ùìï ‚Üí‚Çó[‚ÑÇ]
          FieldOpAlgebra ùìï ‚Üí‚Çó[‚ÑÇ] FieldOpAlgebra ùìï where
        toFun := Quotient.lift superCommuteRight superCommuteRight_eq_of_equiv
        map_add' x y := by
          obtain ‚ü®x, rfl‚ü© := Œπ_surjective x
          obtain ‚ü®y, rfl‚ü© := Œπ_surjective y
          ext b
          obtain ‚ü®b, rfl‚ü© := Œπ_surjective b
          rw [‚Üê map_add, Œπ_apply, Œπ_apply, Œπ_apply, Œπ_apply]
          rw [Quotient.lift_mk, Quotient.lift_mk, Quotient.lift_mk]
          simp only [LinearMap.add_apply]
          rw [superCommuteRight_apply_quot, superCommuteRight_apply_quot, superCommuteRight_apply_quot]
          simp
        map_smul' c y := by
          obtain ‚ü®y, rfl‚ü© := Œπ_surjective y
          ext b
          obtain ‚ü®b, rfl‚ü© := Œπ_surjective b
          rw [‚Üê map_smul, Œπ_apply, Œπ_apply, Œπ_apply]
          simp only [Quotient.lift_mk, RingHom.id_apply, LinearMap.smul_apply]
          rw [superCommuteRight_apply_quot, superCommuteRight_apply_quot]
          simp
    declNo: "2.31"

  - type: h1
    sectionNo: 3
    content: "Time ordering"

  - type: name
    name: FieldSpecification.crAnTimeOrderRel
    line: 194
    fileName: PhysLean.QFT.PerturbationTheory.FieldSpecification.TimeOrder
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldSpecification/TimeOrder.lean#L194"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, `ùìï.crAnTimeOrderRel` is a relation on
        `ùìï.CrAnFieldOp` representing time ordering.
        It is defined such that `ùìï.crAnTimeOrderRel œÜ‚ÇÄ œÜ‚ÇÅ` is true if and only if one of the following
        holds
      - `œÜ‚ÇÄ` is an *outgoing* asymptotic operator
      - `œÜ‚ÇÅ` is an *incoming* asymptotic field operator
      - `œÜ‚ÇÄ` and `œÜ‚ÇÅ` are both position field operators where
        the `SpaceTime` point of `œÜ‚ÇÄ` has a time *greater* than or equal to that of `œÜ‚ÇÅ`.
      
      Thus, colloquially `ùìï.crAnTimeOrderRel œÜ‚ÇÄ œÜ‚ÇÅ` if `œÜ‚ÇÄ` has time *greater* than or equal to `œÜ‚ÇÅ`.
      The use of *greater* than rather then *less* than is because on ordering lists of operators
      it is needed that the operator with the greatest time is to the left.
      
    declString: |
      def crAnTimeOrderRel (a b : ùìï.CrAnFieldOp) : Prop := ùìï.timeOrderRel a.1 b.1
    declNo: "3.1"

  - type: name
    name: FieldSpecification.crAnTimeOrderList
    line: 255
    fileName: PhysLean.QFT.PerturbationTheory.FieldSpecification.TimeOrder
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldSpecification/TimeOrder.lean#L255"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, and a list `œÜs` of `ùìï.CrAnFieldOp`,
      `ùìï.crAnTimeOrderList œÜs` is the list `œÜs` time-ordered using the insertion sort algorithm. 
    declString: |
      def crAnTimeOrderList (œÜs : List ùìï.CrAnFieldOp) : List ùìï.CrAnFieldOp :=
        List.insertionSort ùìï.crAnTimeOrderRel œÜs
    declNo: "3.2"

  - type: name
    name: FieldSpecification.crAnTimeOrderSign
    line: 226
    fileName: PhysLean.QFT.PerturbationTheory.FieldSpecification.TimeOrder
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldSpecification/TimeOrder.lean#L226"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, and a list `œÜs` of `ùìï.CrAnFieldOp`,
      `ùìï.crAnTimeOrderSign œÜs` is the sign corresponding to the number of `ferimionic`-`fermionic`
      exchanges undertaken to time-order (i.e. order with respect to `ùìï.crAnTimeOrderRel`) `œÜs` using
      the insertion sort algorithm. 
    declString: |
      def crAnTimeOrderSign (œÜs : List ùìï.CrAnFieldOp) : ‚ÑÇ :=
        Wick.koszulSign ùìï.crAnStatistics ùìï.crAnTimeOrderRel œÜs
    declNo: "3.3"

  - type: name
    name: FieldSpecification.FieldOpFreeAlgebra.timeOrderF
    line: 29
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpFreeAlgebra.TimeOrder
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpFreeAlgebra/TimeOrder.lean#L29"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, `timeOrderF` is the linear map
      
      `FieldOpFreeAlgebra ùìï ‚Üí‚Çó[‚ÑÇ] FieldOpFreeAlgebra ùìï`
      
      defined by its action on the basis `ofCrAnListF œÜs`, taking
      `ofCrAnListF œÜs` to
      
      `crAnTimeOrderSign œÜs ‚Ä¢ ofCrAnListF (crAnTimeOrderList œÜs)`.
      
      That is, `timeOrderF` time-orders the field operators and multiplies by the sign of the
      time order.
      
      The notation `ùì£·∂†(a)` is used for `timeOrderF a` 
    declString: |
      def timeOrderF : FieldOpFreeAlgebra ùìï ‚Üí‚Çó[‚ÑÇ] FieldOpFreeAlgebra ùìï :=
        Basis.constr ofCrAnListFBasis ‚ÑÇ fun œÜs =>
        crAnTimeOrderSign œÜs ‚Ä¢ ofCrAnListF (crAnTimeOrderList œÜs)
    declNo: "3.4"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.timeOrder
    line: 370
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.TimeOrder
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/TimeOrder.lean#L370"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, `timeOrder` is the linear map
      
      `FieldOpAlgebra ùìï ‚Üí‚Çó[‚ÑÇ] FieldOpAlgebra ùìï`
      
      defined as the descent of `Œπ ‚àò‚Çó timeOrderF : FieldOpFreeAlgebra ùìï ‚Üí‚Çó[‚ÑÇ] FieldOpAlgebra ùìï` from
      `FieldOpFreeAlgebra ùìï` to `FieldOpAlgebra ùìï`.
      This descent exists because `Œπ ‚àò‚Çó timeOrderF` is well-defined on equivalence classes.
      
      The notation `ùì£(a)` is used for `timeOrder a`. 
    declString: |
      noncomputable def timeOrder : FieldOpAlgebra ùìï ‚Üí‚Çó[‚ÑÇ] FieldOpAlgebra ùìï where
        toFun := Quotient.lift (Œπ.toLinearMap ‚àò‚Çó timeOrderF) Œπ_timeOrderF_eq_of_equiv
        map_add' x y := by
          obtain ‚ü®x, hx‚ü© := Œπ_surjective x
          obtain ‚ü®y, hy‚ü© := Œπ_surjective y
          subst hx hy
          rw [‚Üê map_add, Œπ_apply, Œπ_apply, Œπ_apply]
          rw [Quotient.lift_mk, Quotient.lift_mk, Quotient.lift_mk]
          simp
        map_smul' c y := by
          obtain ‚ü®y, hy‚ü© := Œπ_surjective y
          subst hy
          rw [‚Üê map_smul, Œπ_apply, Œπ_apply]
          simp
    declNo: "3.5"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.timeOrder_eq_maxTimeField_mul_finset
    line: 434
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.TimeOrder
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/TimeOrder.lean#L434"
    isDef: false
    isThm: false
    docString: |
      For a field specification `ùìï`, the time order operator acting on a
      list of `ùìï.FieldOp`, `ùì£(œÜ‚ÇÄ‚Ä¶œÜ‚Çô)`, is equal to
      `ùì¢(œÜ·µ¢,œÜ‚ÇÄ‚Ä¶œÜ·µ¢‚Çã‚ÇÅ) ‚Ä¢ œÜ·µ¢ * ùì£(œÜ‚ÇÄ‚Ä¶œÜ·µ¢‚Çã‚ÇÅœÜ·µ¢‚Çä‚ÇÅœÜ‚Çô)` where `œÜ·µ¢` is the maximal time field
      operator in `œÜ‚ÇÄ‚Ä¶œÜ‚Çô`.
      
      The proof of this result ultimately relies on basic properties of ordering and signs. 
    declString: |
      lemma timeOrder_eq_maxTimeField_mul_finset (œÜ : ùìï.FieldOp) (œÜs : List ùìï.FieldOp) :
          ùì£(ofFieldOpList (œÜ :: œÜs)) = ùì¢(ùìï |>‚Çõ maxTimeField œÜ œÜs, ùìï |>‚Çõ ‚ü®(eraseMaxTimeField œÜ œÜs).get,
            (Finset.univ.filter (fun x =>
              (maxTimeFieldPosFin œÜ œÜs).succAbove x < maxTimeFieldPosFin œÜ œÜs))‚ü©) ‚Ä¢
            ofFieldOp (maxTimeField œÜ œÜs) * ùì£(ofFieldOpList (eraseMaxTimeField œÜ œÜs)) := by
        rw [ofFieldOpList, timeOrder_eq_Œπ_timeOrderF, timeOrderF_eq_maxTimeField_mul_finset]
        rfl
    declNo: "3.6"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.timeOrder_timeOrder_mid
    line: 501
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.TimeOrder
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/TimeOrder.lean#L501"
    isDef: false
    isThm: false
    docString: |
      For a field specification `ùìï`, and `a`, `b`, `c` in `ùìï.FieldOpAlgebra`, then
      `ùì£(a * b * c) = ùì£(a * ùì£(b) * c)`. 
    declString: |
      lemma timeOrder_timeOrder_mid (a b c : ùìï.FieldOpAlgebra) :
          ùì£(a * b * c) = ùì£(a * ùì£(b) * c) := by
        obtain ‚ü®a, rfl‚ü© := Œπ_surjective a
        obtain ‚ü®b, rfl‚ü© := Œπ_surjective b
        obtain ‚ü®c, rfl‚ü© := Œπ_surjective c
        rw [‚Üê map_mul, ‚Üê map_mul, timeOrder_eq_Œπ_timeOrderF, timeOrder_eq_Œπ_timeOrderF,
        ‚Üê map_mul, ‚Üê map_mul, timeOrder_eq_Œπ_timeOrderF, timeOrderF_timeOrderF_mid]
    declNo: "3.7"

  - type: h1
    sectionNo: 4
    content: "Normal ordering"

  - type: name
    name: FieldSpecification.normalOrderRel
    line: 17
    fileName: PhysLean.QFT.PerturbationTheory.FieldSpecification.NormalOrder
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldSpecification/NormalOrder.lean#L17"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, `ùìï.normalOrderRel` is a relation on `ùìï.CrAnFieldOp`
      representing normal ordering. It is defined such that `ùìï.normalOrderRel œÜ‚ÇÄ œÜ‚ÇÅ`
      is true if one of the following is true
      - `œÜ‚ÇÄ` is a field creation operator
      - `œÜ‚ÇÅ` is a field annihilation operator.
      
      Thus, colloquially `ùìï.normalOrderRel œÜ‚ÇÄ œÜ‚ÇÅ` says the creation operators are less than
      annihilation operators. 
    declString: |
      def normalOrderRel : ùìï.CrAnFieldOp ‚Üí ùìï.CrAnFieldOp ‚Üí Prop :=
        fun a b => CreateAnnihilate.normalOrder (ùìï |>·∂ú a) (ùìï |>·∂ú b)
    declNo: "4.1"

  - type: name
    name: FieldSpecification.normalOrderList
    line: 225
    fileName: PhysLean.QFT.PerturbationTheory.FieldSpecification.NormalOrder
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldSpecification/NormalOrder.lean#L225"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, and a list `œÜs` of `ùìï.CrAnFieldOp`,
      `ùìï.normalOrderList œÜs` is the list `œÜs` normal-ordered using ther
      insertion sort algorithm. It puts creation operators on the left and annihilation operators on
      the right. For example:
      
      `ùìï.normalOrderList [œÜ1c, œÜ1a, œÜ2c, œÜ2a] = [œÜ1c, œÜ2c, œÜ1a, œÜ2a]`
      
    declString: |
      def normalOrderList (œÜs : List ùìï.CrAnFieldOp) : List ùìï.CrAnFieldOp :=
        List.insertionSort ùìï.normalOrderRel œÜs
    declNo: "4.2"

  - type: name
    name: FieldSpecification.normalOrderSign
    line: 46
    fileName: PhysLean.QFT.PerturbationTheory.FieldSpecification.NormalOrder
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldSpecification/NormalOrder.lean#L46"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, and a list `œÜs` of `ùìï.CrAnFieldOp`, `ùìï.normalOrderSign œÜs` is the
      sign corresponding to the number of `fermionic`-`fermionic` exchanges undertaken to normal-order
      `œÜs` using the insertion sort algorithm. 
    declString: |
      def normalOrderSign (œÜs : List ùìï.CrAnFieldOp) : ‚ÑÇ :=
        Wick.koszulSign ùìï.crAnStatistics ùìï.normalOrderRel œÜs
    declNo: "4.3"

  - type: name
    name: FieldSpecification.normalOrderSign_eraseIdx
    line: 347
    fileName: PhysLean.QFT.PerturbationTheory.FieldSpecification.NormalOrder
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldSpecification/NormalOrder.lean#L347"
    isDef: false
    isThm: false
    docString: |
      For a field specification `ùìï`, a list `œÜs = œÜ‚ÇÄ‚Ä¶œÜ‚Çô` of `ùìï.CrAnFieldOp` and an `i < œÜs.length`,
      then
      `normalOrderSign (œÜ‚ÇÄ‚Ä¶œÜ·µ¢‚Çã‚ÇÅœÜ·µ¢‚Çä‚ÇÅ‚Ä¶œÜ‚Çô)` is equal to the product of
      - `normalOrderSign œÜ‚ÇÄ‚Ä¶œÜ‚Çô`,
      - `ùì¢(œÜ·µ¢, œÜ‚ÇÄ‚Ä¶œÜ·µ¢‚Çã‚ÇÅ)` i.e. the sign needed to remove `œÜ·µ¢` from `œÜ‚ÇÄ‚Ä¶œÜ‚Çô`,
      - `ùì¢(œÜ·µ¢, _)` where `_` is the list of elements appearing before `œÜ·µ¢` after normal ordering,
        i.e.
        the sign needed to insert `œÜ·µ¢` back into the normal-ordered list at the correct place. 
    declString: |
      lemma normalOrderSign_eraseIdx (œÜs : List ùìï.CrAnFieldOp) (i : Fin œÜs.length) :
          normalOrderSign (œÜs.eraseIdx i) = normalOrderSign œÜs *
          ùì¢(ùìï |>‚Çõ (œÜs.get i), ùìï |>‚Çõ (œÜs.take i)) *
          ùì¢(ùìï |>‚Çõ (œÜs.get i), ùìï |>‚Çõ ((normalOrderList œÜs).take (normalOrderEquiv i))) := by
        rw [normalOrderSign, Wick.koszulSign_eraseIdx, ‚Üê normalOrderSign]
        rfl
    declNo: "4.4"

  - type: name
    name: FieldSpecification.FieldOpFreeAlgebra.normalOrderF
    line: 30
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpFreeAlgebra.NormalOrder
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpFreeAlgebra/NormalOrder.lean#L30"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, `normalOrderF` is the linear map
      
      `FieldOpFreeAlgebra ùìï ‚Üí‚Çó[‚ÑÇ] FieldOpFreeAlgebra ùìï`
      
      defined by its action on the basis `ofCrAnListF œÜs`, taking `ofCrAnListF œÜs` to
      
      `normalOrderSign œÜs ‚Ä¢ ofCrAnListF (normalOrderList œÜs)`.
      
      That is, `normalOrderF` normal-orders the field operators and multiplies by the sign of the
      normal order.
      
      The notation `ùìù·∂†(a)` is used for `normalOrderF a` for `a` an element of
      `FieldOpFreeAlgebra ùìï`. 
    declString: |
      def normalOrderF : FieldOpFreeAlgebra ùìï ‚Üí‚Çó[‚ÑÇ] FieldOpFreeAlgebra ùìï :=
        Basis.constr ofCrAnListFBasis ‚ÑÇ fun œÜs =>
        normalOrderSign œÜs ‚Ä¢ ofCrAnListF (normalOrderList œÜs)
    declNo: "4.5"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.normalOrder
    line: 222
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.NormalOrder.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/NormalOrder/Basic.lean#L222"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, `normalOrder` is the linear map
      
      `FieldOpAlgebra ùìï ‚Üí‚Çó[‚ÑÇ] FieldOpAlgebra ùìï`
      
      defined as the descent of `Œπ ‚àò‚Çó normalOrderF : FieldOpFreeAlgebra ùìï ‚Üí‚Çó[‚ÑÇ] FieldOpAlgebra ùìï`
      from `FieldOpFreeAlgebra ùìï` to `FieldOpAlgebra ùìï`.
      This descent exists because `Œπ ‚àò‚Çó normalOrderF` is well-defined on equivalence classes.
      
      The notation `ùìù(a)` is used for `normalOrder a` for `a` an element of `FieldOpAlgebra ùìï`. 
    declString: |
      noncomputable def normalOrder : FieldOpAlgebra ùìï ‚Üí‚Çó[‚ÑÇ] FieldOpAlgebra ùìï where
        toFun := Quotient.lift (Œπ.toLinearMap ‚àò‚Çó normalOrderF) Œπ_normalOrderF_eq_of_equiv
        map_add' x y := by
          obtain ‚ü®x, rfl‚ü© := Œπ_surjective x
          obtain ‚ü®y, rfl‚ü© := Œπ_surjective y
          rw [‚Üê map_add, Œπ_apply, Œπ_apply, Œπ_apply]
          rw [Quotient.lift_mk, Quotient.lift_mk, Quotient.lift_mk]
          simp
        map_smul' c y := by
          obtain ‚ü®y, rfl‚ü© := Œπ_surjective y
          rw [‚Üê map_smul, Œπ_apply, Œπ_apply]
          simp
    declNo: "4.6"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.normalOrder_superCommute_eq_zero
    line: 121
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.NormalOrder.Lemmas
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/NormalOrder/Lemmas.lean#L121"
    isDef: false
    isThm: false
    docString: |
      For a field specification `ùìï`, and `a` and `b` in `ùìï.FieldOpAlgebra` the normal ordering
      of the super commutator of `a` and `b` vanishes, i.e. `ùìù([a,b]‚Çõ) = 0`. 
    declString: |
      lemma normalOrder_superCommute_eq_zero (a b : ùìï.FieldOpAlgebra) :
          ùìù([a, b]‚Çõ) = 0 := by
        obtain ‚ü®a, rfl‚ü© := Œπ_surjective a
        obtain ‚ü®b, rfl‚ü© := Œπ_surjective b
        rw [superCommute_eq_Œπ_superCommuteF, normalOrder_eq_Œπ_normalOrderF]
        simp
    declNo: "4.7"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.ofCrAnOp_superCommute_normalOrder_ofCrAnList_sum
    line: 221
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.NormalOrder.Lemmas
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/NormalOrder/Lemmas.lean#L221"
    isDef: false
    isThm: false
    docString: |
      For a field specification `ùìï`, an element `œÜ` of `ùìï.CrAnFieldOp`, a list `œÜs` of `ùìï.CrAnFieldOp`,
        the following relation holds
      
      `[œÜ, ùìù(œÜ‚ÇÄ‚Ä¶œÜ‚Çô)]‚Çõ = ‚àë i, ùì¢(œÜ, œÜ‚ÇÄ‚Ä¶œÜ·µ¢‚Çã‚ÇÅ) ‚Ä¢ [œÜ, œÜ·µ¢]‚Çõ * ùìù(œÜ‚ÇÄ‚Ä¶œÜ·µ¢‚Çã‚ÇÅœÜ·µ¢‚Çä‚ÇÅ‚Ä¶œÜ‚Çô)`.
      
      The proof of this result ultimately goes as follows
      - The definition of `normalOrder` is used to rewrite `ùìù(œÜ‚ÇÄ‚Ä¶œÜ‚Çô)` as a scalar multiple of
        a `ofCrAnList œÜsn` where `œÜsn` is the normal ordering of `œÜ‚ÇÄ‚Ä¶œÜ‚Çô`.
      - `superCommuteF_ofCrAnListF_ofCrAnListF_eq_sum` is used to rewrite the super commutator of `œÜ`
        (considered as a list with one element) with
        `ofCrAnList œÜsn` as a sum of super commutators, one for each element of `œÜsn`.
      - The fact that super-commutators are in the center of `ùìï.FieldOpAlgebra` is used to rearrange
        terms.
      - Properties of ordered lists, and `normalOrderSign_eraseIdx` are then used to complete the proof.
      
    declString: |
      lemma ofCrAnOp_superCommute_normalOrder_ofCrAnList_sum (œÜ : ùìï.CrAnFieldOp)
          (œÜs : List ùìï.CrAnFieldOp) : [ofCrAnOp œÜ, ùìù(ofCrAnList œÜs)]‚Çõ = ‚àë n : Fin œÜs.length,
          ùì¢(ùìï |>‚Çõ œÜ, ùìï |>‚Çõ (œÜs.take n)) ‚Ä¢ [ofCrAnOp œÜ, ofCrAnOp œÜs[n]]‚Çõ
          * ùìù(ofCrAnList (œÜs.eraseIdx n)) := by
        rw [normalOrder_ofCrAnList, map_smul]
        rw [superCommute_ofCrAnOp_ofCrAnList_eq_sum, Finset.smul_sum,
          sum_normalOrderList_length]
        congr
        funext n
        simp only [instCommGroup.eq_1, List.get_eq_getElem, normalOrderList_get_normalOrderEquiv,
          normalOrderList_eraseIdx_normalOrderEquiv, Algebra.smul_mul_assoc, Fin.getElem_fin]
        rw [ofCrAnList_eq_normalOrder, mul_smul_comm, smul_smul, smul_smul]
        by_cases hs : (ùìï |>‚Çõ œÜ) = (ùìï |>‚Çõ œÜs[n])
        ¬∑ congr
          erw [normalOrderSign_eraseIdx, ‚Üê hs]
          trans (normalOrderSign œÜs * normalOrderSign œÜs) *
            (ùì¢(ùìï |>‚Çõ (œÜs.get n), ùìï |>‚Çõ ((normalOrderList œÜs).take (normalOrderEquiv n))) *
            ùì¢(ùìï |>‚Çõ (œÜs.get n), ùìï |>‚Çõ ((normalOrderList œÜs).take (normalOrderEquiv n))))
            * ùì¢(ùìï |>‚Çõ (œÜs.get n), ùìï |>‚Çõ (œÜs.take n))
          ¬∑ ring_nf
            rw [hs]
            rfl
          ¬∑ simp [hs]
        ¬∑ erw [superCommute_diff_statistic hs]
          simp
    declNo: "4.8"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.ofFieldOp_mul_normalOrder_ofFieldOpList_eq_sum
    line: 347
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.NormalOrder.Lemmas
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/NormalOrder/Lemmas.lean#L347"
    isDef: false
    isThm: false
    docString: |
      For a field specification `ùìï`, a `œÜ` in `ùìï.FieldOp` and a list `œÜs` of `ùìï.FieldOp`
      then `œÜ * ùìù(œÜ‚ÇÄœÜ‚ÇÅ‚Ä¶œÜ‚Çô)` is equal to
      
      `ùìù(œÜœÜ‚ÇÄœÜ‚ÇÅ‚Ä¶œÜ‚Çô) + ‚àë i, (ùì¢(œÜ,œÜ‚ÇÄœÜ‚ÇÅ‚Ä¶œÜ·µ¢‚Çã‚ÇÅ) ‚Ä¢ [anPart œÜ, œÜ·µ¢]‚Çõ) * ùìù(œÜ‚ÇÄ‚Ä¶œÜ·µ¢‚Çã‚ÇÅœÜ·µ¢‚Çä‚ÇÅ‚Ä¶œÜ‚Çô)`.
      
      The proof ultimately goes as follows:
      - `ofFieldOp_eq_crPart_add_anPart` is used to split `œÜ` into its creation and annihilation parts.
      - The following relation is then used
      
        `crPart œÜ * ùìù(œÜ‚ÇÄœÜ‚ÇÅ‚Ä¶œÜ‚Çô) = ùìù(crPart œÜ * œÜ‚ÇÄœÜ‚ÇÅ‚Ä¶œÜ‚Çô)`.
      
      - It used that `anPart œÜ * ùìù(œÜ‚ÇÄœÜ‚ÇÅ‚Ä¶œÜ‚Çô)` is equal to
      
        `ùì¢(œÜ, œÜ‚ÇÄœÜ‚ÇÅ‚Ä¶œÜ‚Çô) ùìù(œÜ‚ÇÄœÜ‚ÇÅ‚Ä¶œÜ‚Çô) * anPart œÜ + [anPart œÜ, ùìù(œÜ‚ÇÄœÜ‚ÇÅ‚Ä¶œÜ‚Çô)]`
      
      - Then it is used that
      
        `ùì¢(œÜ, œÜ‚ÇÄœÜ‚ÇÅ‚Ä¶œÜ‚Çô) ùìù(œÜ‚ÇÄœÜ‚ÇÅ‚Ä¶œÜ‚Çô) * anPart œÜ = ùìù(anPart œÜ * œÜ‚ÇÄœÜ‚ÇÅ‚Ä¶œÜ‚Çô)`
      
      - The result `ofCrAnOp_superCommute_normalOrder_ofCrAnList_sum` is used
        to expand `[anPart œÜ, ùìù(œÜ‚ÇÄœÜ‚ÇÅ‚Ä¶œÜ‚Çô)]` as a sum.
      
    declString: |
      lemma ofFieldOp_mul_normalOrder_ofFieldOpList_eq_sum (œÜ : ùìï.FieldOp) (œÜs : List ùìï.FieldOp) :
          ofFieldOp œÜ * ùìù(ofFieldOpList œÜs) =
          ‚àë n : Option (Fin œÜs.length), contractStateAtIndex œÜ œÜs n *
          ùìù(ofFieldOpList (optionEraseZ œÜs œÜ n)) := by
        rw [ofFieldOp_mul_normalOrder_ofFieldOpList_eq_superCommute]
        rw [anPart_superCommute_normalOrder_ofFieldOpList_sum]
        simp only [instCommGroup.eq_1, Fin.getElem_fin, Algebra.smul_mul_assoc, contractStateAtIndex,
          Fintype.sum_option, one_mul]
        rfl
    declNo: "4.9"

  - type: h1
    sectionNo: 5
    content: "Wick Contractions"

  - type: h2
    sectionNo: "5.1"
    content: "Definition"

  - type: name
    name: WickContraction
    line: 16
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/Basic.lean#L16"
    isDef: true
    isThm: false
    docString: |
      Given a natural number `n`, which will correspond to the number of fields needing
      contracting, a Wick contraction
      is a finite set of pairs of `Fin n` (numbers `0`, ..., `n-1`), such that no
      element of `Fin n` occurs in more than one pair. The pairs are the positions of fields we
      'contract' together.
      
    declString: |
      def WickContraction (n : ‚Ñï) : Type :=
        {f : Finset ((Finset (Fin n))) // (‚àÄ a ‚àà f, a.card = 2) ‚àß
          (‚àÄ a ‚àà f, ‚àÄ b ‚àà f, a = b ‚à® Disjoint a b)}
    declNo: "5.1"

  - type: name
    name: WickContraction.mem_three
    line: 110
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.ExtractEquiv
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/ExtractEquiv.lean#L110"
    isDef: false
    isThm: false
    docString: |
      For `n = 3` there are `4` possible Wick contractions:
      
      - `‚àÖ`, corresponding to the case where no fields are contracted.
      - `{{0, 1}}`, corresponding to the case where the field at position `0` and `1` are contracted.
      - `{{0, 2}}`, corresponding to the case where the field at position `0` and `2` are contracted.
      - `{{1, 2}}`, corresponding to the case where the field at position `1` and `2` are contracted.
      
      The proof of this result uses the fact that Lean is an executable programming language
      and can calculate all Wick contractions for a given `n`. 
    declString: |
      lemma mem_three (c : WickContraction 3) : c.1 ‚àà ({‚àÖ, {{0, 1}}, {{0, 2}}, {{1, 2}}} :
          Finset (Finset (Finset (Fin 3)))) := by
        fin_cases c <;>
          simp only [Fin.isValue, Nat.succ_eq_add_one, Nat.reduceAdd, Function.Embedding.coeFn_mk,
            Finset.mem_insert, Finset.mem_singleton]
        ¬∑ exact Or.inl rfl
        ¬∑ exact Or.inr (Or.inl rfl)
        ¬∑ exact Or.inr (Or.inr (Or.inl rfl))
        ¬∑ exact Or.inr (Or.inr (Or.inr rfl))
    declNo: "5.2"

  - type: name
    name: WickContraction.mem_four
    line: 129
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.ExtractEquiv
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/ExtractEquiv.lean#L129"
    isDef: false
    isThm: false
    docString: |
      For `n = 4` there are `10` possible Wick contractions including e.g.
      
      - `‚àÖ`, corresponding to the case where no fields are contracted.
      - `{{0, 1}, {2, 3}}`, corresponding to the case where the fields at position `0` and `1` are
        contracted, and the fields at position `2` and `3` are contracted.
      - `{{0, 2}, {1, 3}}`, corresponding to the case where the fields at position `0` and `2` are
        contracted, and the fields at position `1` and `3` are contracted.
      
      The proof of this result uses the fact that Lean is an executable programming language
      and can calculate all Wick contractions for a given `n`.
      
    declString: |
      lemma mem_four (c : WickContraction 4) : c.1 ‚àà ({‚àÖ,
          {{0, 1}}, {{0, 2}}, {{0, 3}}, {{1, 2}}, {{1, 3}}, {{2,3}},
          {{0, 1}, {2, 3}}, {{0, 2}, {1, 3}}, {{0, 3}, {1, 2}}} :
          Finset (Finset (Finset (Fin 4)))) := by
        fin_cases c <;>
          simp only [Fin.isValue, Nat.succ_eq_add_one, Nat.reduceAdd, Function.Embedding.coeFn_mk,
            Finset.mem_insert, Finset.mem_singleton]
        ¬∑ exact Or.inl rfl -- ‚àÖ
        ¬∑ exact Or.inr (Or.inl rfl) -- {{0, 1}}
        ¬∑ exact Or.inr (Or.inr (Or.inl rfl)) -- {{0, 2}}
        ¬∑ exact Or.inr (Or.inr (Or.inr (Or.inl rfl))) -- {{0, 3}}
        ¬∑ exact Or.inr (Or.inr (Or.inr (Or.inr (Or.inl rfl)))) -- {{1, 2}}
        ¬∑ exact Or.inr (Or.inr (Or.inr (Or.inr (Or.inr (Or.inr (Or.inr (Or.inr (Or.inr rfl))))))))
        ¬∑ exact Or.inr (Or.inr (Or.inr (Or.inr (Or.inr (Or.inl rfl))))) -- {{1, 3}}
        ¬∑ exact Or.inr (Or.inr (Or.inr (Or.inr (Or.inr (Or.inr (Or.inr (Or.inr (Or.inl rfl))))))))
        ¬∑ exact Or.inr (Or.inr (Or.inr (Or.inr (Or.inr (Or.inr (Or.inl rfl)))))) -- {{2, 3 }}
        ¬∑ exact Or.inr (Or.inr (Or.inr (Or.inr (Or.inr (Or.inr (Or.inr (Or.inl rfl)))))))
    declNo: "5.3"

  - type: remark
    name: "contraction_notation"
    status : "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/Basic.lean#L31"
    content: |
      Given a field specification `ùìï`, and a list `œÜs`
        of `ùìï.FieldOp`, a Wick contraction of `œÜs` will mean a Wick contraction in
        `WickContraction œÜs.length`. The notation `œÜsŒõ` will be used for such contractions.
        The terminology that `œÜsŒõ` contracts pairs within of `œÜs` will also be used, even though
        `œÜsŒõ` is really contains positions of `œÜs`.

  - type: name
    name: WickContraction.GradingCompliant
    line: 520
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/Basic.lean#L520"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, `œÜs` a list of `ùìï.FieldOp` and a Wick contraction
      `œÜsŒõ` of `œÜs`, the Wick contraction `œÜsŒõ` is said to be `GradingCompliant` if
      for every pair in `œÜsŒõ` the contracted fields are either both `fermionic` or both `bosonic`.
      In other words, in a `GradingCompliant` Wick contraction if
      no contracted pairs occur between `fermionic` and `bosonic` fields. 
    declString: |
      def GradingCompliant (œÜs : List ùìï.FieldOp) (œÜsŒõ : WickContraction œÜs.length) :=
        ‚àÄ (a : œÜsŒõ.1), (ùìï |>‚Çõ œÜs[œÜsŒõ.fstFieldOfContract a]) = (ùìï |>‚Çõ œÜs[œÜsŒõ.sndFieldOfContract a])
    declNo: "5.4"

  - type: h2
    sectionNo: "5.2"
    content: "Aside: Cardinality"

  - type: name
    name: WickContraction.card_eq_cardFun
    line: 240
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.Card
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/Card.lean#L240"
    isDef: false
    isThm: true
    docString: |
      The number of Wick contractions in `WickContraction n` is equal to the terms in
      Online Encyclopedia of Integer Sequences (OEIS) A000085. That is:
      1, 1, 2, 4, 10, 26, 76, 232, 764, 2620, 9496, ... 
    declString: |
      theorem card_eq_cardFun : (n : ‚Ñï) ‚Üí Fintype.card (WickContraction n) = cardFun n
        | 0 => by decide
        | 1 => by decide
        | Nat.succ (Nat.succ n) => by
          rw [wickContraction_card_eq_sum_zero_none_isSome, wickContraction_zero_none_card,
            wickContraction_zero_some_eq_mul]
          simp only [cardFun, succ_eq_add_one]
          rw [‚Üê card_eq_cardFun n, ‚Üê card_eq_cardFun (n + 1)]
    declNo: "5.5"

  - type: h2
    sectionNo: "5.3"
    content: "Uncontracted elements"

  - type: name
    name: WickContraction.uncontracted
    line: 19
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.Uncontracted
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/Uncontracted.lean#L19"
    isDef: true
    isThm: false
    docString: |
      For a Wick contraction `c`, `c.uncontracted` is defined as the finset of elements of `Fin n`
      which are not in any contracted pair. 
    declString: |
      def uncontracted : Finset (Fin n) := Finset.filter (fun i => c.getDual? i = none) (Finset.univ)
    declNo: "5.6"

  - type: name
    name: WickContraction.uncontractedListGet
    line: 317
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.UncontractedList
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/UncontractedList.lean#L317"
    isDef: true
    isThm: false
    docString: |
      Given a Wick Contraction `œÜsŒõ` of a list `œÜs` of `ùìï.FieldOp`. The list
      `œÜsŒõ.uncontractedListGet` of `ùìï.FieldOp` is defined as the list `œÜs` with
      all contracted positions removed, leaving the uncontracted `ùìï.FieldOp`.
      
      The notation `[œÜsŒõ]·µò·∂ú` is used for `œÜsŒõ.uncontractedListGet`. 
    declString: |
      def uncontractedListGet {œÜs : List ùìï.FieldOp} (œÜsŒõ : WickContraction œÜs.length) :
          List ùìï.FieldOp := œÜsŒõ.uncontractedList.map œÜs.get
    declNo: "5.7"

  - type: h2
    sectionNo: "5.4"
    content: "Constructors"

  - type: name
    name: WickContraction.insertAndContract
    line: 27
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.InsertAndContract
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/InsertAndContract.lean#L27"
    isDef: true
    isThm: false
    docString: |
      Given a Wick contraction `œÜsŒõ` for a list `œÜs` of `ùìï.FieldOp`,
      an element `œÜ` of `ùìï.FieldOp`, an `i ‚â§ œÜs.length` and a `k`
      in `Option œÜsŒõ.uncontracted` i.e. is either `none` or
      some element of `œÜsŒõ.uncontracted`, the new Wick contraction
      `œÜsŒõ.insertAndContract œÜ i k` is defined by inserting `œÜ` into `œÜs` after
      the first `i`-elements and moving the values representing the contracted pairs in `œÜsŒõ`
      accordingly.
      If `k` is not `none`, but rather `some k`, to this contraction is added the contraction
      of `œÜ` (at position `i`) with the new position of `k` after `œÜ` is added.
      
      In other words, `œÜsŒõ.insertAndContract œÜ i k` is formed by adding `œÜ` to `œÜs` at position `i`,
      and contracting `œÜ` with the field originally at position `k` if `k` is not `none`.
      It is a Wick contraction of the list `œÜs.insertIdx œÜ i` corresponding to `œÜs` with `œÜ` inserted at
      position `i`.
      
      The notation `œÜsŒõ ‚Ü©Œõ œÜ i k` is used to denote `œÜsŒõ.insertAndContract œÜ i k`. 
    declString: |
      def insertAndContract {œÜs : List ùìï.FieldOp} (œÜ : ùìï.FieldOp) (œÜsŒõ : WickContraction œÜs.length)
          (i : Fin œÜs.length.succ) (k : Option œÜsŒõ.uncontracted) :
          WickContraction (œÜs.insertIdx i œÜ).length :=
        congr (by simp) (œÜsŒõ.insertAndContractNat i k)
    declNo: "5.8"

  - type: name
    name: WickContraction.insertLift_sum
    line: 290
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.InsertAndContract
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/InsertAndContract.lean#L290"
    isDef: false
    isThm: false
    docString: |
      For a list `œÜs` of `ùìï.FieldOp`, a Wick contraction `œÜsŒõ` of `œÜs`, an element `œÜ` of
      `ùìï.FieldOp` and a `i ‚â§ œÜs.length` then a sum over
      Wick contractions of `œÜs` with `œÜ` inserted at `i` is equal to the sum over Wick contractions
      `œÜsŒõ` of just `œÜs` and the sum over optional uncontracted elements of the `œÜsŒõ`.
      
      In other words,
      
      `‚àë (œÜsŒõ : WickContraction (œÜs.insertIdx i œÜ).length), f œÜsŒõ`
      
      where `(œÜs.insertIdx i œÜ)` is `œÜs` with `œÜ` inserted at position `i`. is equal to
      
      `‚àë (œÜsŒõ : WickContraction œÜs.length), ‚àë k, f (œÜsŒõ ‚Ü©Œõ œÜ i k) `.
      
      where the sum over `k` is over all `k` in `Option œÜsŒõ.uncontracted`. 
    declString: |
      lemma insertLift_sum (œÜ : ùìï.FieldOp) {œÜs : List ùìï.FieldOp}
          (i : Fin œÜs.length.succ) [AddCommMonoid M] (f : WickContraction (œÜs.insertIdx i œÜ).length ‚Üí M) :
          ‚àë c, f c =
          ‚àë (œÜsŒõ : WickContraction œÜs.length), ‚àë (k : Option œÜsŒõ.uncontracted), f (œÜsŒõ ‚Ü©Œõ œÜ i k) := by
        rw [sum_extractEquiv_congr (finCongr (insertIdx_length_fin œÜ œÜs i).symm i) f
          (insertIdx_length_fin œÜ œÜs i)]
        rfl
    declNo: "5.9"

  - type: name
    name: WickContraction.join
    line: 26
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.Join
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/Join.lean#L26"
    isDef: true
    isThm: false
    docString: |
      Given a list `œÜs` of `ùìï.FieldOp`, a Wick contraction `œÜsŒõ` of `œÜs` and a Wick contraction
      `œÜsucŒõ` of `[œÜsŒõ]·µò·∂ú`, `join œÜsŒõ œÜsucŒõ` is defined as the Wick contraction of `œÜs` consisting of
      the contractions in `œÜsŒõ` and those in `œÜsucŒõ`.
      
      As an example, for `œÜs = [œÜ1, œÜ2, œÜ3, œÜ4]`,
      `œÜsŒõ = {{0, 1}}` corresponding to the contraction of `œÜ1` and `œÜ2` in `œÜs` and
      `œÜsucŒõ = {{0, 1}}`
      corresponding to the contraction of `œÜ3` and `œÜ4` in `[œÜsŒõ]·µò·∂ú = [œÜ3, œÜ4]`, then
      `join œÜsŒõ œÜsucŒõ` is the contraction `{{0, 1}, {2, 3}}` of `œÜs`. 
    declString: |
      def join {œÜs : List ùìï.FieldOp} (œÜsŒõ : WickContraction œÜs.length)
          (œÜsucŒõ : WickContraction [œÜsŒõ]·µò·∂ú.length) : WickContraction œÜs.length :=
        ‚ü®œÜsŒõ.1 ‚à™ œÜsucŒõ.1.map (Finset.mapEmbedding uncontractedListEmd).toEmbedding, by
          intro a ha
          simp only [Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,
            RelEmbedding.coe_toEmbedding] at ha
          rcases ha with ha | ha
          ¬∑ exact œÜsŒõ.2.1 a ha
          ¬∑ obtain ‚ü®a, ha, rfl‚ü© := ha
            rw [Finset.mapEmbedding_apply]
            simp only [Finset.card_map]
            exact œÜsucŒõ.2.1 a ha, by
          intro a ha b hb
          simp only [Finset.le_eq_subset, Finset.mem_union, Finset.mem_map,
            RelEmbedding.coe_toEmbedding] at ha hb
          rcases ha with ha | ha <;> rcases hb with hb | hb
          ¬∑ exact œÜsŒõ.2.2 a ha b hb
          ¬∑ obtain ‚ü®b, hb, rfl‚ü© := hb
            right
            symm
            rw [Finset.mapEmbedding_apply]
            apply uncontractedListEmd_finset_disjoint_left
            exact ha
          ¬∑ obtain ‚ü®a, ha, rfl‚ü© := ha
            right
            rw [Finset.mapEmbedding_apply]
            apply uncontractedListEmd_finset_disjoint_left
            exact hb
          ¬∑ obtain ‚ü®a, ha, rfl‚ü© := ha
            obtain ‚ü®b, hb, rfl‚ü© := hb
            simp only [EmbeddingLike.apply_eq_iff_eq]
            rw [Finset.mapEmbedding_apply, Finset.mapEmbedding_apply]
            rw [Finset.disjoint_map]
            exact œÜsucŒõ.2.2 a ha b hb‚ü©
    declNo: "5.10"

  - type: h2
    sectionNo: "5.5"
    content: "Sign"

  - type: name
    name: WickContraction.sign
    line: 32
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.Sign.Basic
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/Sign/Basic.lean#L32"
    isDef: true
    isThm: false
    docString: |
      For a list `œÜs` of `ùìï.FieldOp`, and a Wick contraction `œÜsŒõ` of `œÜs`,
        the complex number `œÜsŒõ.sign` is defined to be the sign (`1` or `-1`) corresponding
        to the number of `fermionic`-`fermionic` exchanges that must be done to put
        contracted pairs within `œÜsŒõ` next to one another, starting recursively
        from the contracted pair
        whose first element occurs at the left-most position.
      
        As an example, if `[œÜ1, œÜ2, œÜ3, œÜ4]` correspond to fermionic fields then the sign
        associated with
      - `{{0, 1}}` is `1`
      - `{{0, 1}, {2, 3}}` is `1`
      - `{{0, 2}, {1, 3}}` is `-1`
      
    declString: |
      def sign (œÜs : List ùìï.FieldOp) (œÜsŒõ : WickContraction œÜs.length) : ‚ÑÇ :=
        ‚àè (a : œÜsŒõ.1), ùì¢(ùìï |>‚Çõ œÜs[œÜsŒõ.sndFieldOfContract a],
          ùìï |>‚Çõ ‚ü®œÜs.get, œÜsŒõ.signFinset (œÜsŒõ.fstFieldOfContract a) (œÜsŒõ.sndFieldOfContract a)‚ü©)
    declNo: "5.11"

  - type: name
    name: WickContraction.join_sign
    line: 420
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.Sign.Join
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/Sign/Join.lean#L420"
    isDef: false
    isThm: false
    docString: |
      For a list `œÜs` of `ùìï.FieldOp`, a grading compliant Wick contraction `œÜsŒõ` of `œÜs`,
      and a Wick contraction `œÜsucŒõ` of `[œÜsŒõ]·µò·∂ú`, the following relation holds
      `(join œÜsŒõ œÜsucŒõ).sign = œÜsŒõ.sign * œÜsucŒõ.sign`.
      
      In `œÜsŒõ.sign` the sign is determined by starting with the contracted pair
      whose first element occurs at the left-most position. This lemma manifests that this
      choice does not matter, and that contracted pairs can be brought together in any order. 
    declString: |
      lemma join_sign {œÜs : List ùìï.FieldOp} (œÜsŒõ : WickContraction œÜs.length)
          (œÜsucŒõ : WickContraction [œÜsŒõ]·µò·∂ú.length) (hc : œÜsŒõ.GradingCompliant) :
          (join œÜsŒõ œÜsucŒõ).sign = œÜsŒõ.sign * œÜsucŒõ.sign :=
        join_sign_induction œÜsŒõ œÜsucŒõ hc (œÜsŒõ).1.card rfl
    declNo: "5.12"

  - type: name
    name: WickContraction.sign_insert_none
    line: 241
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.Sign.InsertNone
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/Sign/InsertNone.lean#L241"
    isDef: false
    isThm: false
    docString: |
      For a list `œÜs = œÜ‚ÇÄ‚Ä¶œÜ‚Çô` of `ùìï.FieldOp`, a graded compliant Wick contraction `œÜsŒõ` of `œÜs`,
      an `i ‚â§ œÜs.length`, and a `œÜ` in `ùìï.FieldOp`, then
      `(œÜsŒõ ‚Ü©Œõ œÜ i none).sign = s * œÜsŒõ.sign`
      where `s` is the sign arrived at by moving `œÜ` through the elements of `œÜ‚ÇÄ‚Ä¶œÜ·µ¢‚Çã‚ÇÅ` which
      are contracted with some element.
      
      The proof of this result involves a careful consideration of the contributions of different
      `FieldOp`s in `œÜs` to the sign of `œÜsŒõ ‚Ü©Œõ œÜ i none`. 
    declString: |
      lemma sign_insert_none (œÜ : ùìï.FieldOp) (œÜs : List ùìï.FieldOp)
          (œÜsŒõ : WickContraction œÜs.length) (i : Fin œÜs.length.succ) (hG : GradingCompliant œÜs œÜsŒõ) :
          (œÜsŒõ ‚Ü©Œõ œÜ i none).sign = ùì¢(ùìï |>‚Çõ œÜ, ùìï |>‚Çõ ‚ü®œÜs.get, Finset.univ.filter
          (fun x => (œÜsŒõ.getDual? x).isSome ‚àß i.succAbove x < i)‚ü©) * œÜsŒõ.sign := by
        rw [sign_insert_none_eq_signInsertNone_mul_sign]
        rw [signInsertNone_eq_filterset]
        exact hG
    declNo: "5.13"

  - type: name
    name: WickContraction.sign_insert_none_zero
    line: 257
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.Sign.InsertNone
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/Sign/InsertNone.lean#L257"
    isDef: false
    isThm: false
    docString: |
      For a list `œÜs = œÜ‚ÇÄ‚Ä¶œÜ‚Çô` of `ùìï.FieldOp`, a graded compliant Wick contraction `œÜsŒõ` of `œÜs`,
      and a `œÜ` in `ùìï.FieldOp`, then `(œÜsŒõ ‚Ü©Œõ œÜ 0 none).sign = œÜsŒõ.sign`.
      
      This is a direct corollary of `sign_insert_none`. 
    declString: |
      lemma sign_insert_none_zero (œÜ : ùìï.FieldOp) (œÜs : List ùìï.FieldOp)
          (œÜsŒõ : WickContraction œÜs.length) : (œÜsŒõ ‚Ü©Œõ œÜ 0 none).sign = œÜsŒõ.sign := by
        rw [sign_insert_none_eq_signInsertNone_mul_sign]
        simp [signInsertNone]
    declNo: "5.14"

  - type: name
    name: WickContraction.sign_insert_some_of_not_lt
    line: 882
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.Sign.InsertSome
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/Sign/InsertSome.lean#L882"
    isDef: false
    isThm: false
    docString: |
      For a list `œÜs = œÜ‚ÇÄ‚Ä¶œÜ‚Çô` of `ùìï.FieldOp`, a Wick contraction `œÜsŒõ` of `œÜs`, an element `œÜ` of
        `ùìï.FieldOp`, a `i ‚â§ œÜs.length` and a `k` in `œÜsŒõ.uncontracted` such that `i ‚â§ k`,
      the sign of `œÜsŒõ ‚Ü©Œõ œÜ i (some k)` is equal to the product of
      - the sign associated with moving `œÜ` through the `œÜsŒõ`-uncontracted `FieldOp` in `œÜ‚ÇÄ‚Ä¶œÜ‚Çñ‚Çã‚ÇÅ`,
      - the sign associated with moving `œÜ` through all the `FieldOp` in `œÜ‚ÇÄ‚Ä¶œÜ·µ¢‚Çã‚ÇÅ`,
      - the sign of `œÜsŒõ`.
      
      The proof of this result involves a careful consideration of the contributions of different
      `FieldOp` in `œÜs` to the sign of `œÜsŒõ ‚Ü©Œõ œÜ i (some k)`.
      
    declString: |
      lemma sign_insert_some_of_not_lt (œÜ : ùìï.FieldOp) (œÜs : List ùìï.FieldOp)
          (œÜsŒõ : WickContraction œÜs.length) (i : Fin œÜs.length.succ) (k : œÜsŒõ.uncontracted)
          (hk : ¬¨ i.succAbove k < i) (hg : GradingCompliant œÜs œÜsŒõ ‚àß (ùìï |>‚Çõ œÜ) = ùìï |>‚Çõ œÜs[k.1]) :
          (œÜsŒõ ‚Ü©Œõ œÜ i (some k)).sign =
          ùì¢(ùìï |>‚Çõ œÜ, ùìï |>‚Çõ ‚ü®œÜs.get, œÜsŒõ.uncontracted.filter (fun x => x < ‚Üëk)‚ü©)
          * ùì¢(ùìï |>‚Çõ œÜ, ùìï |>‚Çõ ‚ü®œÜs.get, Finset.univ.filter (fun x => i.succAbove x < i)‚ü©) *
          œÜsŒõ.sign := by
        rw [sign_insert_some,
          ‚Üê signInsertSome_mul_filter_contracted_of_not_lt œÜ œÜs œÜsŒõ i k hk hg]
        rw [‚Üê mul_assoc]
        congr 1
        rw [mul_comm, ‚Üê mul_assoc]
        simp
    declNo: "5.15"

  - type: name
    name: WickContraction.sign_insert_some_of_lt
    line: 857
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.Sign.InsertSome
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/Sign/InsertSome.lean#L857"
    isDef: false
    isThm: false
    docString: |
      For a list `œÜs = œÜ‚ÇÄ‚Ä¶œÜ‚Çô` of `ùìï.FieldOp`, a Wick contraction `œÜsŒõ` of `œÜs`, an element `œÜ` of
        `ùìï.FieldOp`, a `i ‚â§ œÜs.length` and a `k` in `œÜsŒõ.uncontracted` such that `k<i`,
      the sign of `œÜsŒõ ‚Ü©Œõ œÜ i (some k)` is equal to the product of
      - the sign associated with moving `œÜ` through the `œÜsŒõ`-uncontracted `FieldOp` in `œÜ‚ÇÄ‚Ä¶œÜ‚Çñ`,
      - the sign associated with moving `œÜ` through all `FieldOp` in `œÜ‚ÇÄ‚Ä¶œÜ·µ¢‚Çã‚ÇÅ`,
      - the sign of `œÜsŒõ`.
      
      The proof of this result involves a careful consideration of the contributions of different
      `FieldOp` in `œÜs` to the sign of `œÜsŒõ ‚Ü©Œõ œÜ i (some k)`.
      
    declString: |
      lemma sign_insert_some_of_lt (œÜ : ùìï.FieldOp) (œÜs : List ùìï.FieldOp)
          (œÜsŒõ : WickContraction œÜs.length) (i : Fin œÜs.length.succ) (k : œÜsŒõ.uncontracted)
          (hk : i.succAbove k < i) (hg : GradingCompliant œÜs œÜsŒõ ‚àß (ùìï |>‚Çõ œÜ) = ùìï |>‚Çõ œÜs[k.1]) :
          (œÜsŒõ ‚Ü©Œõ œÜ i (some k)).sign =
          ùì¢(ùìï |>‚Çõ œÜ, ùìï |>‚Çõ ‚ü®œÜs.get, œÜsŒõ.uncontracted.filter (fun x => x ‚â§ ‚Üëk)‚ü©)
          * ùì¢(ùìï |>‚Çõ œÜ, ùìï |>‚Çõ ‚ü®œÜs.get, Finset.univ.filter (fun x => i.succAbove x < i)‚ü©)
          * œÜsŒõ.sign := by
        rw [sign_insert_some,
          ‚Üê signInsertSome_mul_filter_contracted_of_lt œÜ œÜs œÜsŒõ i k hk hg]
        rw [‚Üê mul_assoc]
        congr 1
        rw [mul_comm, ‚Üê mul_assoc]
        simp
    declNo: "5.16"

  - type: name
    name: WickContraction.sign_insert_some_zero
    line: 907
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.Sign.InsertSome
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/Sign/InsertSome.lean#L907"
    isDef: false
    isThm: false
    docString: |
      For a list `œÜs = œÜ‚ÇÄ‚Ä¶œÜ‚Çô` of `ùìï.FieldOp`, a Wick contraction `œÜsŒõ` of `œÜs`, an element `œÜ` of
        `ùìï.FieldOp`, and a `k` in `œÜsŒõ.uncontracted`,
      the sign of `œÜsŒõ ‚Ü©Œõ œÜ 0 (some k)` is equal to the product of
      - the sign associated with moving `œÜ` through the `œÜsŒõ`-uncontracted `FieldOp` in `œÜ‚ÇÄ‚Ä¶œÜ‚Çñ‚Çã‚ÇÅ`,
      - the sign of `œÜsŒõ`.
      
      This is a direct corollary of `sign_insert_some_of_not_lt`.
      
    declString: |
      lemma sign_insert_some_zero (œÜ : ùìï.FieldOp) (œÜs : List ùìï.FieldOp)
          (œÜsŒõ : WickContraction œÜs.length) (k : œÜsŒõ.uncontracted)
          (hn : GradingCompliant œÜs œÜsŒõ ‚àß (ùìï|>‚ÇõœÜ) = ùìï|>‚ÇõœÜs[k.1]) :
          (œÜsŒõ ‚Ü©Œõ œÜ 0 k).sign = ùì¢(ùìï|>‚ÇõœÜ, ùìï |>‚Çõ ‚ü®œÜs.get, (œÜsŒõ.uncontracted.filter (fun x => x < ‚Üëk))‚ü©) *
          œÜsŒõ.sign := by
        rw [sign_insert_some_of_not_lt]
        ¬∑ simp
        ¬∑ simp
        ¬∑ exact hn
    declNo: "5.17"

  - type: h2
    sectionNo: "5.6"
    content: "Normal order"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.normalOrder_uncontracted_none
    line: 28
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.NormalOrder.WickContractions
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/NormalOrder/WickContractions.lean#L28"
    isDef: false
    isThm: false
    docString: |
      For a list `œÜs = œÜ‚ÇÄ‚Ä¶œÜ‚Çô` of `ùìï.FieldOp`, a Wick contraction `œÜsŒõ` of `œÜs`, an element `œÜ` of
      `ùìï.FieldOp`, and a `i ‚â§ œÜs.length`, then the following relation holds:
      
      `ùìù([œÜsŒõ ‚Ü©Œõ œÜ i none]·µò·∂ú) = s ‚Ä¢ ùìù(œÜ :: [œÜsŒõ]·µò·∂ú)`
      
      where `s` is the exchange sign for `œÜ` and the uncontracted fields in `œÜ‚ÇÄ‚Ä¶œÜ·µ¢‚Çã‚ÇÅ`.
      
      The proof of this result ultimately is a consequence of `normalOrder_superCommute_eq_zero`.
      
    declString: |
      lemma normalOrder_uncontracted_none (œÜ : ùìï.FieldOp) (œÜs : List ùìï.FieldOp)
          (i : Fin œÜs.length.succ) (œÜsŒõ : WickContraction œÜs.length) :
          ùìù(ofFieldOpList [œÜsŒõ ‚Ü©Œõ œÜ i none]·µò·∂ú)
          = ùì¢(ùìï |>‚Çõ œÜ, ùìï |>‚Çõ ‚ü®œÜs.get, œÜsŒõ.uncontracted.filter (fun x => i.succAbove x < i)‚ü©) ‚Ä¢
          ùìù(ofFieldOpList (œÜ :: [œÜsŒõ]·µò·∂ú)) := by
        simp only [Nat.succ_eq_add_one, instCommGroup.eq_1]
        rw [ofFieldOpList_normalOrder_insert œÜ [œÜsŒõ]·µò·∂ú
          ‚ü®(œÜsŒõ.uncontractedListOrderPos i), by simp [uncontractedListGet]‚ü©, smul_smul]
        trans (1 : ‚ÑÇ) ‚Ä¢ (ùìù(ofFieldOpList [œÜsŒõ ‚Ü©Œõ œÜ i none]·µò·∂ú))
        ¬∑ simp
        congr 1
        simp only [instCommGroup.eq_1, uncontractedListGet]
        rw [‚Üê List.map_take, take_uncontractedListOrderPos_eq_filter]
        have h1 : (ùìï |>‚Çõ List.map œÜs.get (List.filter (fun x => decide (‚Üëx < i.1)) œÜsŒõ.uncontractedList))
              = ùìï |>‚Çõ ‚ü®œÜs.get, (œÜsŒõ.uncontracted.filter (fun x => x.val < i.1))‚ü© := by
            simp only [Nat.succ_eq_add_one, ofFinset]
            congr
            rw [uncontractedList_eq_sort]
            have hdup : (List.filter (fun x => decide (x.1 < i.1))
                (Finset.sort (fun x1 x2 => x1 ‚â§ x2) œÜsŒõ.uncontracted)).Nodup := by
              exact List.Nodup.filter _ (Finset.sort_nodup (fun x1 x2 => x1 ‚â§ x2) œÜsŒõ.uncontracted)
            have hsort : (List.filter (fun x => decide (x.1 < i.1))
                (Finset.sort (fun x1 x2 => x1 ‚â§ x2) œÜsŒõ.uncontracted)).Sorted (¬∑ ‚â§ ¬∑) := by
              exact List.Sorted.filter _ (Finset.sort_sorted (fun x1 x2 => x1 ‚â§ x2) œÜsŒõ.uncontracted)
            rw [‚Üê (List.toFinset_sort (¬∑ ‚â§ ¬∑) hdup).mpr hsort]
            congr
            ext a
            simp
        rw [h1]
        simp only [Nat.succ_eq_add_one]
        have h2 : (Finset.filter (fun x => x.1 < i.1) œÜsŒõ.uncontracted) =
          (Finset.filter (fun x => i.succAbove x < i) œÜsŒõ.uncontracted) := by
          ext a
          simp only [Nat.succ_eq_add_one, Finset.mem_filter, and_congr_right_iff]
          intro ha
          simp only [Fin.succAbove]
          split
          ¬∑ apply Iff.intro
            ¬∑ intro h
              omega
            ¬∑ intro h
              rename_i h
              rw [Fin.lt_def] at h
              simp only [Fin.coe_castSucc] at h
              omega
          ¬∑ apply Iff.intro
            ¬∑ intro h
              rename_i h'
              rw [Fin.lt_def]
              simp only [Fin.val_succ]
              rw [Fin.lt_def] at h'
              simp only [Fin.coe_castSucc, not_lt] at h'
              omega
            ¬∑ intro h
              rename_i h
              rw [Fin.lt_def] at h
              simp only [Fin.val_succ] at h
              omega
        rw [h2]
        simp only [exchangeSign_mul_self]
        congr
        simp only [Nat.succ_eq_add_one]
        rw [insertAndContract_uncontractedList_none_map]
    declNo: "5.18"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.normalOrder_uncontracted_some
    line: 101
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.NormalOrder.WickContractions
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/NormalOrder/WickContractions.lean#L101"
    isDef: false
    isThm: false
    docString: |
      For a list `œÜs = œÜ‚ÇÄ‚Ä¶œÜ‚Çô` of `ùìï.FieldOp`, a Wick contraction `œÜsŒõ` of `œÜs`, an element `œÜ` of
      `ùìï.FieldOp`, a `i ‚â§ œÜs.length` and a `k` in `œÜsŒõ.uncontracted`, then
      `ùìù([œÜsŒõ ‚Ü©Œõ œÜ i (some k)]·µò·∂ú)` is equal to the normal ordering of `[œÜsŒõ]·µò·∂ú` with the `ùìï.FieldOp`
      corresponding to `k` removed.
      
      The proof of this result ultimately is a consequence of definitions.
      
    declString: |
      lemma normalOrder_uncontracted_some (œÜ : ùìï.FieldOp) (œÜs : List ùìï.FieldOp)
          (i : Fin œÜs.length.succ) (œÜsŒõ : WickContraction œÜs.length) (k : œÜsŒõ.uncontracted) :
          ùìù(ofFieldOpList [œÜsŒõ ‚Ü©Œõ œÜ i (some k)]·µò·∂ú)
          = ùìù(ofFieldOpList (optionEraseZ [œÜsŒõ]·µò·∂ú œÜ ((uncontractedFieldOpEquiv œÜs œÜsŒõ) k))) := by
        simp only [Nat.succ_eq_add_one, insertAndContract, optionEraseZ, uncontractedFieldOpEquiv,
          Equiv.optionCongr_apply, Equiv.coe_trans, Option.map_some', Function.comp_apply, finCongr_apply,
          Fin.coe_cast, uncontractedListGet]
        congr
        rw [congr_uncontractedList]
        erw [uncontractedList_extractEquiv_symm_some]
        simp only [Fin.coe_succAboveEmb, List.map_eraseIdx, List.map_map]
        congr
        conv_rhs => rw [get_eq_insertIdx_succAbove œÜ œÜs i]
    declNo: "5.19"

  - type: h1
    sectionNo: 6
    content: "Static Wick's theorem"

  - type: h2
    sectionNo: "6.1"
    content: "Static contractions"

  - type: name
    name: WickContraction.staticContract
    line: 22
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.StaticContract
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/StaticContract.lean#L22"
    isDef: true
    isThm: false
    docString: |
      For a list `œÜs` of `ùìï.FieldOp` and a Wick contraction `œÜsŒõ`, the
      element of the center of `ùìï.FieldOpAlgebra`, `œÜsŒõ.staticContract` is defined as the product
      of `[anPart œÜs[j], œÜs[k]]‚Çõ` over contracted pairs `{j, k}` in `œÜsŒõ`
      with `j < k`. 
    declString: |
      noncomputable def staticContract {œÜs : List ùìï.FieldOp}
          (œÜsŒõ : WickContraction œÜs.length) :
          Subalgebra.center ‚ÑÇ ùìï.FieldOpAlgebra :=
        ‚àè (a : œÜsŒõ.1), ‚ü®[anPart (œÜs.get (œÜsŒõ.fstFieldOfContract a)),
          ofFieldOp (œÜs.get (œÜsŒõ.sndFieldOfContract a))]‚Çõ,
            superCommute_anPart_ofFieldOp_mem_center _ _‚ü©
    declNo: "6.1"

  - type: name
    name: WickContraction.staticContract_insert_none
    line: 33
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.StaticContract
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/StaticContract.lean#L33"
    isDef: false
    isThm: false
    docString: |
      For a list `œÜs = œÜ‚ÇÄ‚Ä¶œÜ‚Çô` of `ùìï.FieldOp`, a Wick contraction `œÜsŒõ` of `œÜs`, an element `œÜ` of
      `ùìï.FieldOp`, and a `i ‚â§ œÜs.length`, then the following relation holds:
      
      `(œÜsŒõ ‚Ü©Œõ œÜ i none).staticContract = œÜsŒõ.staticContract`
      
      The proof of this result ultimately is a consequence of definitions.
      
    declString: |
      lemma staticContract_insert_none (œÜ : ùìï.FieldOp) (œÜs : List ùìï.FieldOp)
          (œÜsŒõ : WickContraction œÜs.length) (i : Fin œÜs.length.succ) :
          (œÜsŒõ ‚Ü©Œõ œÜ i none).staticContract = œÜsŒõ.staticContract := by
        rw [staticContract, insertAndContract_none_prod_contractions]
        congr
        ext a
        simp
    declNo: "6.2"

  - type: name
    name: WickContraction.staticContract_insert_some
    line: 49
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.StaticContract
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/StaticContract.lean#L49"
    isDef: false
    isThm: false
    docString: |
      For a list `œÜs = œÜ‚ÇÄ‚Ä¶œÜ‚Çô` of `ùìï.FieldOp`, a Wick contraction `œÜsŒõ` of `œÜs`, an element `œÜ` of
      `ùìï.FieldOp`, a `i ‚â§ œÜs.length` and a `k` in `œÜsŒõ.uncontracted`, then
      `(œÜsŒõ ‚Ü©Œõ œÜ i (some k)).staticContract` is equal to the product of
      - `[anPart œÜ, œÜs[k]]‚Çõ` if `i ‚â§ k` or `[anPart œÜs[k], œÜ]‚Çõ` if `k < i`
      - `œÜsŒõ.staticContract`.
      
      The proof of this result ultimately is a consequence of definitions.
      
    declString: |
      lemma staticContract_insert_some
          (œÜ : ùìï.FieldOp) (œÜs : List ùìï.FieldOp)
          (œÜsŒõ : WickContraction œÜs.length) (i : Fin œÜs.length.succ) (j : œÜsŒõ.uncontracted) :
          (œÜsŒõ ‚Ü©Œõ œÜ i (some j)).staticContract =
          (if i < i.succAbove j then
            ‚ü®[anPart œÜ, ofFieldOp œÜs[j.1]]‚Çõ, superCommute_anPart_ofFieldOp_mem_center _ _‚ü©
          else ‚ü®[anPart œÜs[j.1], ofFieldOp œÜ]‚Çõ, superCommute_anPart_ofFieldOp_mem_center _ _‚ü©) *
          œÜsŒõ.staticContract := by
        rw [staticContract, insertAndContract_some_prod_contractions]
        congr 1
        ¬∑ simp only [Nat.succ_eq_add_one, insertAndContract_fstFieldOfContract_some_incl, finCongr_apply,
          List.get_eq_getElem, insertAndContract_sndFieldOfContract_some_incl, Fin.getElem_fin]
          split
          ¬∑ simp
          ¬∑ simp
        ¬∑ congr
          ext a
          simp
    declNo: "6.3"

  - type: h2
    sectionNo: "6.2"
    content: "Static Wick terms"

  - type: name
    name: WickContraction.staticWickTerm
    line: 25
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.StaticWickTerm
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/StaticWickTerm.lean#L25"
    isDef: true
    isThm: false
    docString: |
      For a list `œÜs` of `ùìï.FieldOp`, and a Wick contraction `œÜsŒõ` of `œÜs`, the element
      of `ùìï.FieldOpAlgebra`, `œÜsŒõ.staticWickTerm` is defined as
      
      `œÜsŒõ.sign ‚Ä¢ œÜsŒõ.staticContract * ùìù([œÜsŒõ]·µò·∂ú)`.
      
      This is a term which appears in the static version Wick's theorem. 
    declString: |
      def staticWickTerm {œÜs : List ùìï.FieldOp} (œÜsŒõ : WickContraction œÜs.length) : ùìï.FieldOpAlgebra :=
        œÜsŒõ.sign ‚Ä¢ œÜsŒõ.staticContract * ùìù(ofFieldOpList [œÜsŒõ]·µò·∂ú)
    declNo: "6.4"

  - type: name
    name: WickContraction.staticWickTerm_empty_nil
    line: 34
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.StaticWickTerm
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/StaticWickTerm.lean#L34"
    isDef: false
    isThm: false
    docString: |
      For the empty list `[]` of `ùìï.FieldOp`, the `staticWickTerm` of the Wick contraction
      corresponding to the empty set `‚àÖ` (the only Wick contraction of `[]`) is `1`. 
    declString: |
      lemma staticWickTerm_empty_nil :
          staticWickTerm (empty (n := ([] : List ùìï.FieldOp).length)) = 1 := by
        rw [staticWickTerm, uncontractedListGet, nil_zero_uncontractedList]
        simp [sign, empty, staticContract]
    declNo: "6.5"

  - type: name
    name: WickContraction.staticWickTerm_insert_zero_none
    line: 42
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.StaticWickTerm
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/StaticWickTerm.lean#L42"
    isDef: false
    isThm: false
    docString: |
      For a list `œÜs = œÜ‚ÇÄ‚Ä¶œÜ‚Çô` of `ùìï.FieldOp`, a Wick contraction `œÜsŒõ` of `œÜs`, and an element `œÜ` of
        `ùìï.FieldOp`, then `(œÜsŒõ ‚Ü©Œõ œÜ 0 none).staticWickTerm` is equal to
      
      `œÜsŒõ.sign ‚Ä¢ œÜsŒõ.staticWickTerm * ùìù(œÜ :: [œÜsŒõ]·µò·∂ú)`
      
      The proof of this result relies on
      - `staticContract_insert_none` to rewrite the static contract.
      - `sign_insert_none_zero` to rewrite the sign.
      
    declString: |
      lemma staticWickTerm_insert_zero_none (œÜ : ùìï.FieldOp) (œÜs : List ùìï.FieldOp)
          (œÜsŒõ : WickContraction œÜs.length) :
          (œÜsŒõ ‚Ü©Œõ œÜ 0 none).staticWickTerm =
          œÜsŒõ.sign ‚Ä¢ œÜsŒõ.staticContract * ùìù(ofFieldOpList (œÜ :: [œÜsŒõ]·µò·∂ú)) := by
        symm
        erw [staticWickTerm, sign_insert_none_zero]
        simp only [staticContract_insert_none, insertAndContract_uncontractedList_none_zero,
          Algebra.smul_mul_assoc]
    declNo: "6.6"

  - type: name
    name: WickContraction.staticWickTerm_insert_zero_some
    line: 61
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.StaticWickTerm
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/StaticWickTerm.lean#L61"
    isDef: false
    isThm: false
    docString: |
      For a list `œÜs = œÜ‚ÇÄ‚Ä¶œÜ‚Çô` of `ùìï.FieldOp`, a Wick contraction `œÜsŒõ` of `œÜs`, an element `œÜ` of
        `ùìï.FieldOp`, and a `k` in `œÜsŒõ.uncontracted`, `(œÜsŒõ ‚Ü©Œõ œÜ 0 (some k)).wickTerm` is equal
        to the product of
      - the sign `ùì¢(œÜ, œÜ‚ÇÄ‚Ä¶œÜ·µ¢‚Çã‚ÇÅ) `
      - the sign `œÜsŒõ.sign`
      - `œÜsŒõ.staticContract`
      - `s ‚Ä¢ [anPart œÜ, ofFieldOp œÜs[k]]‚Çõ` where `s` is the sign associated with moving `œÜ` through
        uncontracted fields in `œÜ‚ÇÄ‚Ä¶œÜ‚Çñ‚Çã‚ÇÅ`
      - the normal ordering of `[œÜsŒõ]·µò·∂ú` with the field operator `œÜs[k]` removed.
      
      The proof of this result ultimately relies on
      - `staticContract_insert_some` to rewrite static contractions.
      - `normalOrder_uncontracted_some` to rewrite normal orderings.
      - `sign_insert_some_zero` to rewrite signs.
      
    declString: |
      lemma staticWickTerm_insert_zero_some (œÜ : ùìï.FieldOp) (œÜs : List ùìï.FieldOp)
          (œÜsŒõ : WickContraction œÜs.length) (k : { x // x ‚àà œÜsŒõ.uncontracted }) :
          (œÜsŒõ ‚Ü©Œõ œÜ 0 k).staticWickTerm =
          sign œÜs œÜsŒõ ‚Ä¢ (‚ÜëœÜsŒõ.staticContract *
          (contractStateAtIndex œÜ [œÜsŒõ]·µò·∂ú ((uncontractedFieldOpEquiv œÜs œÜsŒõ) (some k)) *
          ùìù(ofFieldOpList (optionEraseZ [œÜsŒõ]·µò·∂ú œÜ (uncontractedFieldOpEquiv œÜs œÜsŒõ k))))) := by
        symm
        rw [staticWickTerm, normalOrder_uncontracted_some]
        simp only [‚Üê mul_assoc]
        rw [‚Üê smul_mul_assoc]
        congr 1
        rw [staticContract_insert_some_of_lt]
        swap
        ¬∑ simp
        rw [smul_smul]
        by_cases hn : GradingCompliant œÜs œÜsŒõ ‚àß (ùìï|>‚ÇõœÜ) = (ùìï|>‚Çõ œÜs[k.1])
        ¬∑ congr 1
          swap
          ¬∑ rw [Subalgebra.mem_center_iff.mp œÜsŒõ.staticContract.2]
          ¬∑ rw [sign_insert_some_zero _ _ _ _ hn, mul_comm, ‚Üê mul_assoc]
            simp
        ¬∑ simp only [Fin.getElem_fin, not_and] at hn
          by_cases h0 : ¬¨ GradingCompliant œÜs œÜsŒõ
          ¬∑ rw [staticContract_of_not_gradingCompliant]
            simp only [ZeroMemClass.coe_zero, zero_mul, smul_zero, instCommGroup.eq_1, mul_zero]
            exact h0
          ¬∑ simp_all only [Finset.mem_univ, not_not, instCommGroup.eq_1, forall_const]
            have h1 : contractStateAtIndex œÜ [œÜsŒõ]·µò·∂ú (uncontractedFieldOpEquiv œÜs œÜsŒõ k) = 0 := by
              simp only [contractStateAtIndex, uncontractedFieldOpEquiv, Equiv.optionCongr_apply,
                Equiv.coe_trans, Option.map_some', Function.comp_apply, finCongr_apply,
                instCommGroup.eq_1, Fin.coe_cast, Fin.getElem_fin, smul_eq_zero]
              right
              simp only [uncontractedListGet, List.getElem_map,
                uncontractedList_getElem_uncontractedIndexEquiv_symm, List.get_eq_getElem]
              rw [superCommute_anPart_ofFieldOpF_diff_grade_zero]
              exact hn
            rw [h1]
            simp
    declNo: "6.7"

  - type: name
    name: WickContraction.mul_staticWickTerm_eq_sum
    line: 115
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.StaticWickTerm
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/StaticWickTerm.lean#L115"
    isDef: false
    isThm: false
    docString: |
      For a list `œÜs = œÜ‚ÇÄ‚Ä¶œÜ‚Çô` of `ùìï.FieldOp`, a Wick contraction `œÜsŒõ` of `œÜs`, the following relation
      holds
      
      `œÜ * œÜsŒõ.staticWickTerm = ‚àë k, (œÜsŒõ ‚Ü©Œõ œÜ 0 k).staticWickTerm`
      
      where the sum is over all `k` in `Option œÜsŒõ.uncontracted`, so `k` is either `none` or `some k`.
      
      The proof proceeds as follows:
      - `ofFieldOp_mul_normalOrder_ofFieldOpList_eq_sum` is used to expand `œÜ ùìù([œÜsŒõ]·µò·∂ú)` as
        a sum over `k` in `Option œÜsŒõ.uncontracted` of terms involving `[anPart œÜ, œÜs[k]]‚Çõ`.
      - Then `staticWickTerm_insert_zero_none` and `staticWickTerm_insert_zero_some` are
        used to equate terms.
      
    declString: |
      lemma mul_staticWickTerm_eq_sum (œÜ : ùìï.FieldOp) (œÜs : List ùìï.FieldOp)
          (œÜsŒõ : WickContraction œÜs.length) :
          ofFieldOp œÜ * œÜsŒõ.staticWickTerm =
          ‚àë (k : Option œÜsŒõ.uncontracted), (œÜsŒõ ‚Ü©Œõ œÜ 0 k).staticWickTerm := by
        trans (œÜsŒõ.sign ‚Ä¢ œÜsŒõ.staticContract * (ofFieldOp œÜ * normalOrder (ofFieldOpList [œÜsŒõ]·µò·∂ú)))
        ¬∑ have ht := Subalgebra.mem_center_iff.mp (Subalgebra.smul_mem (Subalgebra.center ‚ÑÇ _)
            (œÜsŒõ.staticContract).2 œÜsŒõ.sign)
          conv_rhs => rw [‚Üê mul_assoc, ‚Üê ht]
          simp [mul_assoc, staticWickTerm]
        rw [ofFieldOp_mul_normalOrder_ofFieldOpList_eq_sum]
        rw [Finset.mul_sum]
        rw [uncontractedFieldOpEquiv_list_sum]
        refine Finset.sum_congr rfl (fun n _ => ?_)
        match n with
        | none =>
          simp only [contractStateAtIndex, uncontractedFieldOpEquiv, Equiv.optionCongr_apply,
            Equiv.coe_trans, Option.map_none', one_mul, Algebra.smul_mul_assoc, Nat.succ_eq_add_one,
            Fin.zero_eta, Fin.val_zero, List.insertIdx_zero, staticContract_insert_none,
            insertAndContract_uncontractedList_none_zero]
          rw [staticWickTerm_insert_zero_none]
          simp only [Algebra.smul_mul_assoc]
          rfl
        | some n =>
          simp only [Algebra.smul_mul_assoc, Nat.succ_eq_add_one, Fin.zero_eta, Fin.val_zero,
            List.insertIdx_zero]
          rw [staticWickTerm_insert_zero_some]
    declNo: "6.8"

  - type: h2
    sectionNo: "6.3"
    content: "The Static Wick's theorem"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.static_wick_theorem
    line: 22
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.StaticWickTheorem
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/StaticWickTheorem.lean#L22"
    isDef: false
    isThm: true
    docString: |
      For a list `œÜs` of `ùìï.FieldOp`, the static version of Wick's theorem states that
      
      `œÜs = ‚àë œÜsŒõ, œÜsŒõ.staticWickTerm`
      
      where the sum is over all Wick contraction `œÜsŒõ`.
      
      The proof is via induction on `œÜs`.
      - The base case `œÜs = []` is handled by `staticWickTerm_empty_nil`.
      
      The inductive step works as follows:
      
      For the LHS:
      1. The proof considers `œÜ‚ÇÄ‚Ä¶œÜ‚Çô` as `œÜ‚ÇÄ(œÜ‚ÇÅ‚Ä¶œÜ‚Çô)` and uses the induction hypothesis on `œÜ‚ÇÅ‚Ä¶œÜ‚Çô`.
      2. This gives terms of the form `œÜ * œÜsŒõ.staticWickTerm` on which
        `mul_staticWickTerm_eq_sum` is used where `œÜsŒõ` is a Wick contraction of `œÜ‚ÇÅ‚Ä¶œÜ‚Çô`,
        to rewrite terms as a sum over optional uncontracted elements of `œÜsŒõ`
      
      On the LHS we now have a sum over Wick contractions `œÜsŒõ` of `œÜ‚ÇÅ‚Ä¶œÜ‚Çô` (from 1) and optional
      uncontracted elements of `œÜsŒõ` (from 2)
      
      For the RHS:
      1. The sum over Wick contractions of `œÜ‚ÇÄ‚Ä¶œÜ‚Çô` on the RHS
        is split via `insertLift_sum` into a sum over Wick contractions `œÜsŒõ` of `œÜ‚ÇÅ‚Ä¶œÜ‚Çô` and
        sum over optional uncontracted elements of `œÜsŒõ`.
      
      Both sides are now sums over the same thing and their terms equate by the nature of the
      lemmas used.
      
      
    declString: |
      theorem static_wick_theorem : (œÜs : List ùìï.FieldOp) ‚Üí
          ofFieldOpList œÜs = ‚àë (œÜsŒõ : WickContraction œÜs.length), œÜsŒõ.staticWickTerm
        | [] => by
          simp only [ofFieldOpList, ofFieldOpListF_nil, map_one, List.length_nil]
          rw [sum_WickContraction_nil]
          rw [staticWickTerm_empty_nil]
        | œÜ :: œÜs => by
          rw [ofFieldOpList_cons, static_wick_theorem œÜs]
          rw [show (œÜ :: œÜs) = œÜs.insertIdx (‚ü®0, Nat.zero_lt_succ œÜs.length‚ü© : Fin œÜs.length.succ) œÜ
            from rfl]
          conv_rhs => rw [insertLift_sum]
          rw [Finset.mul_sum]
          apply Finset.sum_congr rfl
          intro c _
          rw [mul_staticWickTerm_eq_sum]
          rfl
    declNo: "6.9"

  - type: h1
    sectionNo: 7
    content: "Wick's theorem"

  - type: h2
    sectionNo: "7.1"
    content: "Time contractions"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.timeContract
    line: 26
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.TimeContraction
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/TimeContraction.lean#L26"
    isDef: true
    isThm: false
    docString: |
      For a field specification `ùìï`, and `œÜ` and `œà` elements of `ùìï.FieldOp`, the element of
      `ùìï.FieldOpAlgebra`, `timeContract œÜ œà` is defined to be `ùì£(œÜœà) - ùìù(œÜœà)`. 
    declString: |
      def timeContract (œÜ œà : ùìï.FieldOp) : ùìï.FieldOpAlgebra :=
          ùì£(ofFieldOp œÜ * ofFieldOp œà) - ùìù(ofFieldOp œÜ * ofFieldOp œà)
    declNo: "7.1"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.timeContract_of_timeOrderRel
    line: 34
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.TimeContraction
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/TimeContraction.lean#L34"
    isDef: false
    isThm: false
    docString: |
      For a field specification `ùìï`, and `œÜ` and `œà` elements of `ùìï.FieldOp`, if
      `œÜ` and `œà` are time-ordered then
      
      `timeContract œÜ œà = [anPart œÜ, ofFieldOp œà]‚Çõ`. 
    declString: |
      lemma timeContract_of_timeOrderRel (œÜ œà : ùìï.FieldOp) (h : timeOrderRel œÜ œà) :
          timeContract œÜ œà = [anPart œÜ, ofFieldOp œà]‚Çõ := by
        conv_rhs =>
          rw [ofFieldOp_eq_crPart_add_anPart]
          rw [map_add, superCommute_anPart_anPart, superCommute_anPart_crPart]
        simp only [timeContract, instCommGroup.eq_1, Algebra.smul_mul_assoc, add_zero]
        rw [timeOrder_ofFieldOp_ofFieldOp_ordered h]
        rw [normalOrder_ofFieldOp_mul_ofFieldOp]
        simp only [instCommGroup.eq_1]
        rw [ofFieldOp_eq_crPart_add_anPart, ofFieldOp_eq_crPart_add_anPart]
        simp only [mul_add, add_mul]
        abel_nf
    declNo: "7.2"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.timeContract_of_not_timeOrderRel_expand
    line: 61
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.TimeContraction
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/TimeContraction.lean#L61"
    isDef: false
    isThm: false
    docString: |
      For a field specification `ùìï`, and `œÜ` and `œà` elements of `ùìï.FieldOp`, if
      `œÜ` and `œà` are not time-ordered then
      
      `timeContract œÜ œà = ùì¢(ùìï |>‚Çõ œÜ, ùìï |>‚Çõ œà) ‚Ä¢ [anPart œà, ofFieldOp œÜ]‚Çõ`. 
    declString: |
      lemma timeContract_of_not_timeOrderRel_expand (œÜ œà : ùìï.FieldOp) (h : ¬¨ timeOrderRel œÜ œà) :
          timeContract œÜ œà = ùì¢(ùìï |>‚Çõ œÜ, ùìï |>‚Çõ œà) ‚Ä¢ [anPart œà, ofFieldOp œÜ]‚Çõ := by
        rw [timeContract_of_not_timeOrderRel _ _ h]
        rw [timeContract_of_timeOrderRel _ _ _]
        have h1 := IsTotal.total (r := ùìï.timeOrderRel) œÜ œà
        simp_all
    declNo: "7.3"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.timeContract_mem_center
    line: 72
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.TimeContraction
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/TimeContraction.lean#L72"
    isDef: false
    isThm: false
    docString: |
      For a field specification `ùìï`, and `œÜ` and `œà` elements of `ùìï.FieldOp`, then
      `timeContract œÜ œà` is in the center of `ùìï.FieldOpAlgebra`. 
    declString: |
      lemma timeContract_mem_center (œÜ œà : ùìï.FieldOp) :
          timeContract œÜ œà ‚àà Subalgebra.center ‚ÑÇ ùìï.FieldOpAlgebra := by
        by_cases h : timeOrderRel œÜ œà
        ¬∑ rw [timeContract_of_timeOrderRel _ _ h]
          exact superCommute_anPart_ofFieldOp_mem_center œÜ œà
        ¬∑ rw [timeContract_of_not_timeOrderRel _ _ h]
          refine Subalgebra.smul_mem (Subalgebra.center ‚ÑÇ _) ?_ ùì¢(ùìï |>‚Çõ œÜ, ùìï |>‚Çõ œà)
          rw [timeContract_of_timeOrderRel]
          exact superCommute_anPart_ofFieldOp_mem_center _ _
          have h1 := IsTotal.total (r := ùìï.timeOrderRel) œÜ œà
          simp_all
    declNo: "7.4"

  - type: name
    name: WickContraction.timeContract
    line: 22
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.TimeContract
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/TimeContract.lean#L22"
    isDef: true
    isThm: false
    docString: |
      For a list `œÜs` of `ùìï.FieldOp` and a Wick contraction `œÜsŒõ` the
      element of the center of `ùìï.FieldOpAlgebra`, `œÜsŒõ.timeContract` is defined as the product
      of `timeContract œÜs[j] œÜs[k]` over contracted pairs `{j, k}` in `œÜsŒõ`
      with `j < k`. 
    declString: |
      noncomputable def timeContract {œÜs : List ùìï.FieldOp}
          (œÜsŒõ : WickContraction œÜs.length) :
          Subalgebra.center ‚ÑÇ ùìï.FieldOpAlgebra :=
        ‚àè (a : œÜsŒõ.1), ‚ü®FieldOpAlgebra.timeContract
          (œÜs.get (œÜsŒõ.fstFieldOfContract a)) (œÜs.get (œÜsŒõ.sndFieldOfContract a)),
          timeContract_mem_center _ _‚ü©
    declNo: "7.5"

  - type: name
    name: WickContraction.timeContract_insert_none
    line: 33
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.TimeContract
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/TimeContract.lean#L33"
    isDef: false
    isThm: false
    docString: |
      For a list `œÜs = œÜ‚ÇÄ‚Ä¶œÜ‚Çô` of `ùìï.FieldOp`, a Wick contraction `œÜsŒõ` of `œÜs`, an element `œÜ` of
      `ùìï.FieldOp`, and a `i ‚â§ œÜs.length` the following relation holds
      
      `(œÜsŒõ ‚Ü©Œõ œÜ i none).timeContract = œÜsŒõ.timeContract`
      
      The proof of this result ultimately is a consequence of definitions. 
    declString: |
      lemma timeContract_insert_none (œÜ : ùìï.FieldOp) (œÜs : List ùìï.FieldOp)
          (œÜsŒõ : WickContraction œÜs.length) (i : Fin œÜs.length.succ) :
          (œÜsŒõ ‚Ü©Œõ œÜ i none).timeContract = œÜsŒõ.timeContract := by
        rw [timeContract, insertAndContract_none_prod_contractions]
        congr
        ext a
        simp
    declNo: "7.6"

  - type: name
    name: WickContraction.timeContract_insert_some_of_not_lt
    line: 126
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.TimeContract
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/TimeContract.lean#L126"
    isDef: false
    isThm: false
    docString: |
      For a list `œÜs = œÜ‚ÇÄ‚Ä¶œÜ‚Çô` of `ùìï.FieldOp`, a Wick contraction `œÜsŒõ` of `œÜs`, an element `œÜ` of
      `ùìï.FieldOp`, a `i ‚â§ œÜs.length` and a `k` in `œÜsŒõ.uncontracted` such that `k < i`, with the
      condition that `œÜs[k]` does not have time greater or equal to `œÜ`, then
      `(œÜsŒõ ‚Ü©Œõ œÜ i (some k)).timeContract` is equal to the product of
      - `[anPart œÜ, œÜs[k]]‚Çõ`
      - `œÜsŒõ.timeContract`
      - the exchange sign of `œÜ` with the uncontracted fields in `œÜ‚ÇÄ‚Ä¶œÜ‚Çñ‚Çã‚ÇÅ`.
      - the exchange sign of `œÜ` with the uncontracted fields in `œÜ‚ÇÄ‚Ä¶œÜ‚Çñ`.
      
      The proof of this result ultimately is a consequence of definitions and
      `timeContract_of_not_timeOrderRel_expand`. 
    declString: |
      lemma timeContract_insert_some_of_not_lt
          (œÜ : ùìï.FieldOp) (œÜs : List ùìï.FieldOp)
          (œÜsŒõ : WickContraction œÜs.length) (i : Fin œÜs.length.succ) (k : œÜsŒõ.uncontracted)
          (ht : ¬¨ ùìï.timeOrderRel œÜs[k.1] œÜ) (hik : ¬¨ i < i.succAbove k) :
          (œÜsŒõ ‚Ü©Œõ œÜ i (some k)).timeContract =
          ùì¢(ùìï |>‚Çõ œÜ, ùìï |>‚Çõ ‚ü®œÜs.get, (œÜsŒõ.uncontracted.filter (fun x => x ‚â§ k))‚ü©)
          ‚Ä¢ (contractStateAtIndex œÜ [œÜsŒõ]·µò·∂ú
            ((uncontractedFieldOpEquiv œÜs œÜsŒõ) (some k)) * œÜsŒõ.timeContract) := by
        rw [timeContract_insertAndContract_some]
        simp only [Nat.succ_eq_add_one, Fin.getElem_fin, ite_mul, instCommGroup.eq_1,
          contractStateAtIndex, uncontractedFieldOpEquiv, Equiv.optionCongr_apply,
          Equiv.coe_trans, Option.map_some', Function.comp_apply, finCongr_apply, Fin.coe_cast,
          List.getElem_map, uncontractedList_getElem_uncontractedIndexEquiv_symm, List.get_eq_getElem,
          Algebra.smul_mul_assoc, uncontractedListGet]
        simp only [hik, ‚ÜìreduceIte, MulMemClass.coe_mul]
        rw [timeContract_of_not_timeOrderRel, timeContract_of_timeOrderRel]
        simp only [instCommGroup.eq_1, Algebra.smul_mul_assoc, smul_smul]
        congr
        have h1 : ofList ùìï.fieldOpStatistic (List.take (‚Üë(œÜsŒõ.uncontractedIndexEquiv.symm k))
            (List.map œÜs.get œÜsŒõ.uncontractedList))
            = (ùìï |>‚Çõ ‚ü®œÜs.get, (Finset.filter (fun x => x < k) œÜsŒõ.uncontracted)‚ü©) := by
          simp only [ofFinset]
          congr
          rw [‚Üê List.map_take]
          congr
          rw [take_uncontractedIndexEquiv_symm, filter_uncontractedList]
        rw [h1]
        trans ùì¢(ùìï |>‚Çõ œÜ, ùìï |>‚Çõ ‚ü®œÜs.get, {k.1}‚ü©)
        ¬∑ rw [exchangeSign_symm, ofFinset_singleton]
          simp
        rw [‚Üê map_mul]
        congr
        rw [ofFinset_union]
        congr
        ext a
        simp only [Finset.mem_singleton, Finset.mem_sdiff, Finset.mem_union, Finset.mem_filter,
          Finset.mem_inter, not_and, not_lt, and_imp]
        apply Iff.intro
        ¬∑ intro h
          subst h
          simp
        ¬∑ intro h
          have h1 := h.1
          rcases h1 with h1 | h1
          ¬∑ have h2' := h.2 h1.1 h1.2 h1.1
            omega
          ¬∑ have h2' := h.2 h1.1 (by omega) h1.1
            omega
        have ht := IsTotal.total (r := timeOrderRel) œÜs[k.1] œÜ
        simp_all only [Fin.getElem_fin, Nat.succ_eq_add_one, not_lt, false_or]
        exact ht
    declNo: "7.7"

  - type: name
    name: WickContraction.timeContract_insert_some_of_lt
    line: 82
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.TimeContract
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/TimeContract.lean#L82"
    isDef: false
    isThm: false
    docString: |
      For a list `œÜs = œÜ‚ÇÄ‚Ä¶œÜ‚Çô` of `ùìï.FieldOp`, a Wick contraction `œÜsŒõ` of `œÜs`, an element `œÜ` of
      `ùìï.FieldOp`, a `i ‚â§ œÜs.length` and a `k` in `œÜsŒõ.uncontracted` such that `i ‚â§ k`, with the
      condition that `œÜ` has greater or equal time to `œÜs[k]`, then
      `(œÜsŒõ ‚Ü©Œõ œÜ i (some k)).timeContract` is equal to the product of
      - `[anPart œÜ, œÜs[k]]‚Çõ`
      - `œÜsŒõ.timeContract`
      - two copies of the exchange sign of `œÜ` with the uncontracted fields in `œÜ‚ÇÄ‚Ä¶œÜ‚Çñ‚Çã‚ÇÅ`.
        These two exchange signs cancel each other out but are included for convenience.
      
      The proof of this result ultimately is a consequence of definitions and
      `timeContract_of_timeOrderRel`. 
    declString: |
      lemma timeContract_insert_some_of_lt
          (œÜ : ùìï.FieldOp) (œÜs : List ùìï.FieldOp)
          (œÜsŒõ : WickContraction œÜs.length) (i : Fin œÜs.length.succ) (k : œÜsŒõ.uncontracted)
          (ht : ùìï.timeOrderRel œÜ œÜs[k.1]) (hik : i < i.succAbove k) :
          (œÜsŒõ ‚Ü©Œõ œÜ i (some k)).timeContract =
          ùì¢(ùìï |>‚Çõ œÜ, ùìï |>‚Çõ ‚ü®œÜs.get, (œÜsŒõ.uncontracted.filter (fun x => x < k))‚ü©)
          ‚Ä¢ (contractStateAtIndex œÜ [œÜsŒõ]·µò·∂ú ((uncontractedFieldOpEquiv œÜs œÜsŒõ) (some k)) *
            œÜsŒõ.timeContract) := by
        rw [timeContract_insertAndContract_some]
        simp only [Nat.succ_eq_add_one, Fin.getElem_fin, ite_mul, instCommGroup.eq_1,
          contractStateAtIndex, uncontractedFieldOpEquiv, Equiv.optionCongr_apply,
          Equiv.coe_trans, Option.map_some', Function.comp_apply, finCongr_apply, Fin.coe_cast,
          List.getElem_map, uncontractedList_getElem_uncontractedIndexEquiv_symm, List.get_eq_getElem,
          Algebra.smul_mul_assoc, uncontractedListGet]
        ¬∑ simp only [hik, ‚ÜìreduceIte, MulMemClass.coe_mul]
          rw [timeContract_of_timeOrderRel]
          trans (1 : ‚ÑÇ) ‚Ä¢ ((superCommute (anPart œÜ)) (ofFieldOp œÜs[k.1]) * ‚ÜëœÜsŒõ.timeContract)
          ¬∑ simp
          simp only [smul_smul]
          congr 1
          have h1 : ofList ùìï.fieldOpStatistic (List.take (‚Üë(œÜsŒõ.uncontractedIndexEquiv.symm k))
              (List.map œÜs.get œÜsŒõ.uncontractedList))
              = (ùìï |>‚Çõ ‚ü®œÜs.get, (Finset.filter (fun x => x < k) œÜsŒõ.uncontracted)‚ü©) := by
            simp only [ofFinset]
            congr
            rw [‚Üê List.map_take]
            congr
            rw [take_uncontractedIndexEquiv_symm]
            rw [filter_uncontractedList]
          rw [h1]
          simp only [exchangeSign_mul_self]
          ¬∑ exact ht
    declNo: "7.8"

  - type: name
    name: WickContraction.join_sign_timeContract
    line: 432
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.Sign.Join
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/Sign/Join.lean#L432"
    isDef: false
    isThm: false
    docString: |
      For a list `œÜs` of `ùìï.FieldOp`, a Wick contraction `œÜsŒõ` of `œÜs`,
      and a Wick contraction `œÜsucŒõ` of `[œÜsŒõ]·µò·∂ú`,
      `(join œÜsŒõ œÜsucŒõ).sign ‚Ä¢ (join œÜsŒõ œÜsucŒõ).timeContract` is equal to the product of
      - `œÜsŒõ.sign ‚Ä¢ œÜsŒõ.timeContract` and
      - `œÜsucŒõ.sign ‚Ä¢ œÜsucŒõ.timeContract`. 
    declString: |
      lemma join_sign_timeContract {œÜs : List ùìï.FieldOp} (œÜsŒõ : WickContraction œÜs.length)
          (œÜsucŒõ : WickContraction [œÜsŒõ]·µò·∂ú.length) :
          (join œÜsŒõ œÜsucŒõ).sign ‚Ä¢ (join œÜsŒõ œÜsucŒõ).timeContract.1 =
          (œÜsŒõ.sign ‚Ä¢ œÜsŒõ.timeContract.1) * (œÜsucŒõ.sign ‚Ä¢ œÜsucŒõ.timeContract.1) := by
        rw [join_timeContract]
        by_cases h : œÜsŒõ.GradingCompliant
        ¬∑ rw [join_sign _ _ h]
          simp [smul_smul, mul_comm]
        ¬∑ rw [timeContract_of_not_gradingCompliant _ _ h]
          simp
    declNo: "7.9"

  - type: h2
    sectionNo: "7.2"
    content: "Wick terms"

  - type: name
    name: WickContraction.wickTerm
    line: 27
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.WickTerm
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/WickTerm.lean#L27"
    isDef: true
    isThm: false
    docString: |
      For a list `œÜs` of `ùìï.FieldOp`, and a Wick contraction `œÜsŒõ` of `œÜs`, the element
      of `ùìï.FieldOpAlgebra`, `œÜsŒõ.wickTerm` is defined as
      
      `œÜsŒõ.sign ‚Ä¢ œÜsŒõ.timeContract * ùìù([œÜsŒõ]·µò·∂ú)`.
      
      This is a term which appears in the Wick's theorem. 
    declString: |
      def wickTerm {œÜs : List ùìï.FieldOp} (œÜsŒõ : WickContraction œÜs.length) : ùìï.FieldOpAlgebra :=
        œÜsŒõ.sign ‚Ä¢ œÜsŒõ.timeContract * ùìù(ofFieldOpList [œÜsŒõ]·µò·∂ú)
    declNo: "7.10"

  - type: name
    name: WickContraction.wickTerm_empty_nil
    line: 36
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.WickTerm
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/WickTerm.lean#L36"
    isDef: false
    isThm: false
    docString: |
      For the empty list `[]` of `ùìï.FieldOp`, the `wickTerm` of the Wick contraction
      corresponding to the empty set `‚àÖ` (the only Wick contraction of `[]`) is `1`. 
    declString: |
      lemma wickTerm_empty_nil :
          wickTerm (empty (n := ([] : List ùìï.FieldOp).length)) = 1 := by
        rw [wickTerm]
        simp [sign_empty]
    declNo: "7.11"

  - type: name
    name: WickContraction.wickTerm_insert_none
    line: 44
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.WickTerm
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/WickTerm.lean#L44"
    isDef: false
    isThm: false
    docString: |
      For a list `œÜs = œÜ‚ÇÄ‚Ä¶œÜ‚Çô` of `ùìï.FieldOp`, a Wick contraction `œÜsŒõ` of `œÜs`, an element `œÜ` of
        `ùìï.FieldOp`, and `i ‚â§ œÜs.length`, then `(œÜsŒõ ‚Ü©Œõ œÜ i none).wickTerm` is equal to
      
      `ùì¢(œÜ, œÜ‚ÇÄ‚Ä¶œÜ·µ¢‚Çã‚ÇÅ) œÜsŒõ.sign ‚Ä¢ œÜsŒõ.timeContract * ùìù(œÜ :: [œÜsŒõ]·µò·∂ú)`
      
      The proof of this result relies on
      - `normalOrder_uncontracted_none` to rewrite normal orderings.
      - `timeContract_insert_none` to rewrite the time contract.
      - `sign_insert_none` to rewrite the sign.
      
    declString: |
      lemma wickTerm_insert_none (œÜ : ùìï.FieldOp) (œÜs : List ùìï.FieldOp)
          (i : Fin œÜs.length.succ) (œÜsŒõ : WickContraction œÜs.length) :
          (œÜsŒõ ‚Ü©Œõ œÜ i none).wickTerm =
          ùì¢(ùìï |>‚Çõ œÜ, ùìï |>‚Çõ ‚ü®œÜs.get, (Finset.univ.filter (fun k => i.succAbove k < i))‚ü©)
          ‚Ä¢ (œÜsŒõ.sign ‚Ä¢ œÜsŒõ.timeContract * ùìù(ofFieldOpList (œÜ :: [œÜsŒõ]·µò·∂ú))) := by
        rw [wickTerm]
        by_cases hg : GradingCompliant œÜs œÜsŒõ
        ¬∑ rw [normalOrder_uncontracted_none, sign_insert_none _ _ _ _ hg]
          simp only [Nat.succ_eq_add_one, timeContract_insert_none, instCommGroup.eq_1,
            Algebra.mul_smul_comm, Algebra.smul_mul_assoc, smul_smul]
          congr 1
          rw [‚Üê mul_assoc]
          congr 1
          rw [‚Üê map_mul]
          congr
          rw [ofFinset_union]
          congr
          ext a
          simp only [Finset.mem_sdiff, Finset.mem_union, Finset.mem_filter, Finset.mem_univ, true_and,
            Finset.mem_inter, not_and, not_lt, and_imp]
          apply Iff.intro
          ¬∑ intro ha
            have ha1 := ha.1
            rcases ha1 with ha1 | ha1
            ¬∑ exact ha1.2
            ¬∑ exact ha1.2
          ¬∑ intro ha
            simp only [uncontracted, Finset.mem_filter, Finset.mem_univ, true_and, ha, and_true,
              forall_const]
            have hx : œÜsŒõ.getDual? a = none ‚Üî ¬¨ (œÜsŒõ.getDual? a).isSome := by
              simp
            rw [hx]
            simp only [Bool.not_eq_true, Bool.eq_false_or_eq_true_self, true_and]
            intro h1 h2
            simp_all
        ¬∑ simp only [Nat.succ_eq_add_one, timeContract_insert_none, Algebra.smul_mul_assoc,
          instCommGroup.eq_1]
          rw [timeContract_of_not_gradingCompliant]
          simp only [ZeroMemClass.coe_zero, zero_mul, smul_zero]
          exact hg
    declNo: "7.12"

  - type: name
    name: WickContraction.wickTerm_insert_some
    line: 96
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.WickTerm
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/WickTerm.lean#L96"
    isDef: false
    isThm: false
    docString: |
      For a list `œÜs = œÜ‚ÇÄ‚Ä¶œÜ‚Çô` of `ùìï.FieldOp`, a Wick contraction `œÜsŒõ` of `œÜs`, an element `œÜ` of
        `ùìï.FieldOp`, `i ‚â§ œÜs.length` and a `k` in `œÜsŒõ.uncontracted`,
        such that all `ùìï.FieldOp` in `œÜ‚ÇÄ‚Ä¶œÜ·µ¢‚Çã‚ÇÅ` have time strictly less than `œÜ` and
        `œÜ` has a time greater than or equal to all `FieldOp` in `œÜ‚ÇÄ‚Ä¶œÜ‚Çô`, then
        `(œÜsŒõ ‚Ü©Œõ œÜ i (some k)).staticWickTerm`
      is equal to the product of
      - the sign `ùì¢(œÜ, œÜ‚ÇÄ‚Ä¶œÜ·µ¢‚Çã‚ÇÅ) `
      - the sign `œÜsŒõ.sign`
      - `œÜsŒõ.timeContract`
      - `s ‚Ä¢ [anPart œÜ, ofFieldOp œÜs[k]]‚Çõ` where `s` is the sign associated with moving `œÜ` through
        uncontracted fields in `œÜ‚ÇÄ‚Ä¶œÜ‚Çñ‚Çã‚ÇÅ`
      - the normal ordering `[œÜsŒõ]·µò·∂ú` with the field corresponding to `k` removed.
      
      The proof of this result relies on
      - `timeContract_insert_some_of_not_lt`
        and `timeContract_insert_some_of_lt` to rewrite time
        contractions.
      - `normalOrder_uncontracted_some` to rewrite normal orderings.
      - `sign_insert_some_of_not_lt` and `sign_insert_some_of_lt` to rewrite signs.
      
    declString: |
      lemma wickTerm_insert_some (œÜ : ùìï.FieldOp) (œÜs : List ùìï.FieldOp)
          (i : Fin œÜs.length.succ) (œÜsŒõ : WickContraction œÜs.length) (k : œÜsŒõ.uncontracted)
          (hlt : ‚àÄ (k : Fin œÜs.length), timeOrderRel œÜ œÜs[k])
          (hn : ‚àÄ (k : Fin œÜs.length), i.succAbove k < i ‚Üí ¬¨ timeOrderRel œÜs[k] œÜ) :
          (œÜsŒõ ‚Ü©Œõ œÜ i (some k)).wickTerm =
          ùì¢(ùìï |>‚Çõ œÜ, ùìï |>‚Çõ ‚ü®œÜs.get, (Finset.univ.filter (fun x => i.succAbove x < i))‚ü©)
          ‚Ä¢ (œÜsŒõ.sign ‚Ä¢ (contractStateAtIndex œÜ [œÜsŒõ]·µò·∂ú
            ((uncontractedFieldOpEquiv œÜs œÜsŒõ) (some k)) * œÜsŒõ.timeContract)
          * ùìù(ofFieldOpList (optionEraseZ [œÜsŒõ]·µò·∂ú œÜ (uncontractedFieldOpEquiv œÜs œÜsŒõ k)))) := by
        rw [wickTerm]
        by_cases hg : GradingCompliant œÜs œÜsŒõ ‚àß (ùìï |>‚Çõ œÜ) = (ùìï |>‚Çõ œÜs[k.1])
        ¬∑ by_cases hk : i.succAbove k < i
          ¬∑ rw [WickContraction.timeContract_insert_some_of_not_lt]
            swap
            ¬∑ exact hn _ hk
            ¬∑ rw [normalOrder_uncontracted_some, sign_insert_some_of_lt œÜ œÜs œÜsŒõ i k hk hg]
              simp only [instCommGroup.eq_1, smul_smul, Algebra.smul_mul_assoc]
              congr 1
              rw [mul_assoc, mul_assoc, mul_comm, mul_assoc, mul_assoc]
              simp
            ¬∑ omega
          ¬∑ have hik : i.succAbove ‚Üëk ‚â† i := Fin.succAbove_ne i ‚Üëk
            rw [timeContract_insert_some_of_lt]
            swap
            ¬∑ exact hlt _
            ¬∑ rw [normalOrder_uncontracted_some]
              rw [sign_insert_some_of_not_lt œÜ œÜs œÜsŒõ i k hk hg]
              simp only [instCommGroup.eq_1, smul_smul, Algebra.smul_mul_assoc]
              congr 1
              rw [mul_assoc, mul_assoc, mul_comm, mul_assoc, mul_assoc]
              simp
            ¬∑ omega
        ¬∑ rw [timeContract_insertAndContract_some]
          simp only [Fin.getElem_fin, not_and] at hg
          by_cases hg' : GradingCompliant œÜs œÜsŒõ
          ¬∑ have hg := hg hg'
            simp only [Nat.succ_eq_add_one, Fin.getElem_fin, ite_mul, Algebra.smul_mul_assoc,
              instCommGroup.eq_1, contractStateAtIndex, uncontractedFieldOpEquiv, Equiv.optionCongr_apply,
              Equiv.coe_trans, Option.map_some', Function.comp_apply, finCongr_apply, Fin.coe_cast,
              List.getElem_map, uncontractedList_getElem_uncontractedIndexEquiv_symm, List.get_eq_getElem,
              uncontractedListGet]
            by_cases h1 : i < i.succAbove ‚Üëk
            ¬∑ simp only [h1, ‚ÜìreduceIte, MulMemClass.coe_mul]
              rw [timeContract_zero_of_diff_grade]
              simp only [zero_mul, smul_zero]
              rw [superCommute_anPart_ofFieldOpF_diff_grade_zero]
              simp only [zero_mul, smul_zero]
              exact hg
              exact hg
            ¬∑ simp only [h1, ‚ÜìreduceIte, MulMemClass.coe_mul]
              rw [timeContract_zero_of_diff_grade]
              simp only [zero_mul, smul_zero]
              rw [superCommute_anPart_ofFieldOpF_diff_grade_zero]
              simp only [zero_mul, smul_zero]
              exact hg
              exact fun a => hg (id (Eq.symm a))
          ¬∑ rw [timeContract_of_not_gradingCompliant]
            simp only [Nat.succ_eq_add_one, Fin.getElem_fin, mul_zero, ZeroMemClass.coe_zero, smul_zero,
              zero_mul, instCommGroup.eq_1]
            exact hg'
    declNo: "7.13"

  - type: name
    name: WickContraction.mul_wickTerm_eq_sum
    line: 177
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.WickTerm
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/WickTerm.lean#L177"
    isDef: false
    isThm: false
    docString: |
      For a list `œÜs = œÜ‚ÇÄ‚Ä¶œÜ‚Çô` of `ùìï.FieldOp`, a Wick contraction `œÜsŒõ` of `œÜs`, an element `œÜ` of
        `ùìï.FieldOp`, and `i ‚â§ œÜs.length`
        such that all `ùìï.FieldOp` in `œÜ‚ÇÄ‚Ä¶œÜ·µ¢‚Çã‚ÇÅ` have time strictly less than `œÜ` and
        `œÜ` has a time greater than or equal to all `FieldOp` in `œÜ‚ÇÄ‚Ä¶œÜ‚Çô`, then
      
      `œÜ * œÜsŒõ.wickTerm = ùì¢(œÜ, œÜ‚ÇÄ‚Ä¶œÜ·µ¢‚Çã‚ÇÅ) ‚Ä¢ ‚àë k, (œÜsŒõ ‚Ü©Œõ œÜ i k).wickTerm`
      
      where the sum is over all `k` in `Option œÜsŒõ.uncontracted`, so `k` is either `none` or `some k`.
      
      The proof proceeds as follows:
      - `ofFieldOp_mul_normalOrder_ofFieldOpList_eq_sum` is used to expand `œÜ ùìù([œÜsŒõ]·µò·∂ú)` as
        a sum over `k` in `Option œÜsŒõ.uncontracted` of terms involving `[anPart œÜ, œÜs[k]]‚Çõ`.
      - Then `wickTerm_insert_none` and `wickTerm_insert_some` are used to equate terms.
      
    declString: |
      lemma mul_wickTerm_eq_sum (œÜ : ùìï.FieldOp) (œÜs : List ùìï.FieldOp) (i : Fin œÜs.length.succ)
          (œÜsŒõ : WickContraction œÜs.length) (hlt : ‚àÄ (k : Fin œÜs.length), timeOrderRel œÜ œÜs[k])
          (hn : ‚àÄ (k : Fin œÜs.length), i.succAbove k < i ‚Üí ¬¨timeOrderRel œÜs[k] œÜ) :
          ofFieldOp œÜ * œÜsŒõ.wickTerm =
          ùì¢(ùìï |>‚Çõ œÜ, ùìï |>‚Çõ ‚ü®œÜs.get, (Finset.univ.filter (fun x => i.succAbove x < i))‚ü©) ‚Ä¢
          ‚àë (k : Option œÜsŒõ.uncontracted), (œÜsŒõ ‚Ü©Œõ œÜ i k).wickTerm := by
        trans (œÜsŒõ.sign ‚Ä¢ œÜsŒõ.timeContract) * ((ofFieldOp œÜ) * ùìù(ofFieldOpList [œÜsŒõ]·µò·∂ú))
        ¬∑ have ht := Subalgebra.mem_center_iff.mp (Subalgebra.smul_mem (Subalgebra.center ‚ÑÇ _)
            (WickContraction.timeContract œÜsŒõ).2 (œÜsŒõ.sign))
          rw [wickTerm]
          rw [‚Üê mul_assoc, ht, mul_assoc]
        rw [ofFieldOp_mul_normalOrder_ofFieldOpList_eq_sum, Finset.mul_sum,
          uncontractedFieldOpEquiv_list_sum, Finset.smul_sum]
        simp only [instCommGroup.eq_1, Nat.succ_eq_add_one]
        congr 1
        funext n
        match n with
        | none =>
          rw [wickTerm_insert_none]
          simp only [contractStateAtIndex, uncontractedFieldOpEquiv, Equiv.optionCongr_apply,
            Equiv.coe_trans, Option.map_none', one_mul, Algebra.smul_mul_assoc, instCommGroup.eq_1,
            smul_smul]
          congr 1
          rw [‚Üê mul_assoc, exchangeSign_mul_self]
          simp
        | some n =>
          rw [wickTerm_insert_some _ _ _ _ _
            (fun k => hlt k) (fun k a => hn k a)]
          simp only [uncontractedFieldOpEquiv, Equiv.optionCongr_apply, Equiv.coe_trans, Option.map_some',
            Function.comp_apply, finCongr_apply, Algebra.smul_mul_assoc, instCommGroup.eq_1, smul_smul]
          congr 1
          ¬∑ rw [‚Üê mul_assoc, exchangeSign_mul_self]
            rw [one_mul]
          ¬∑ rw [‚Üê mul_assoc]
            congr 1
            have ht := (WickContraction.timeContract œÜsŒõ).prop
            rw [@Subalgebra.mem_center_iff] at ht
            rw [ht]
    declNo: "7.14"

  - type: h2
    sectionNo: "7.3"
    content: "Wick's theorem"

  - type: name
    name: FieldSpecification.wicks_theorem
    line: 64
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.WicksTheorem
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/WicksTheorem.lean#L64"
    isDef: false
    isThm: true
    docString: |
      For a list `œÜs` of `ùìï.FieldOp`, Wick's theorem states that
      
      `ùì£(œÜs) = ‚àë œÜsŒõ, œÜsŒõ.wickTerm`
      
      where the sum is over all Wick contraction `œÜsŒõ`.
      
      The proof is via induction on `œÜs`.
      - The base case `œÜs = []` is handled by `wickTerm_empty_nil`.
      
      The inductive step works as follows:
      
      For the LHS:
      1. `timeOrder_eq_maxTimeField_mul_finset` is used to write
        `ùì£(œÜ‚ÇÄ‚Ä¶œÜ‚Çô)` as `ùì¢(œÜ·µ¢,œÜ‚ÇÄ‚Ä¶œÜ·µ¢‚Çã‚ÇÅ) ‚Ä¢ œÜ·µ¢ * ùì£(œÜ‚ÇÄ‚Ä¶œÜ·µ¢‚Çã‚ÇÅœÜ·µ¢‚Çä‚ÇÅœÜ‚Çô)` where `œÜ·µ¢` is
        the maximal time field in `œÜ‚ÇÄ‚Ä¶œÜ‚Çô`
      2. The induction hypothesis is then used on `ùì£(œÜ‚ÇÄ‚Ä¶œÜ·µ¢‚Çã‚ÇÅœÜ·µ¢‚Çä‚ÇÅœÜ‚Çô)` to expand it as a sum over
        Wick contractions of `œÜ‚ÇÄ‚Ä¶œÜ·µ¢‚Çã‚ÇÅœÜ·µ¢‚Çä‚ÇÅœÜ‚Çô`.
      3. This gives terms of the form `œÜ·µ¢ * œÜsŒõ.wickTerm` on which
        `mul_wickTerm_eq_sum` is used where `œÜsŒõ` is a Wick contraction of `œÜ‚ÇÄ‚Ä¶œÜ·µ¢‚Çã‚ÇÅœÜ·µ¢‚Çä‚ÇÅœÜ`,
        to rewrite terms as a sum over optional uncontracted elements of `œÜsŒõ`
      
      On the LHS we now have a sum over Wick contractions `œÜsŒõ` of `œÜ‚ÇÄ‚Ä¶œÜ·µ¢‚Çã‚ÇÅœÜ·µ¢‚Çä‚ÇÅœÜ` (from 2) and optional
      uncontracted elements of `œÜsŒõ` (from 3)
      
      For the RHS:
      1. The sum over Wick contractions of `œÜ‚ÇÄ‚Ä¶œÜ‚Çô` on the RHS
        is split via `insertLift_sum` into a sum over Wick contractions `œÜsŒõ` of `œÜ‚ÇÄ‚Ä¶œÜ·µ¢‚Çã‚ÇÅœÜ·µ¢‚Çä‚ÇÅœÜ` and
        sum over optional uncontracted elements of `œÜsŒõ`.
      
      Both sides are now sums over the same thing and their terms equate by the nature of the
      lemmas used.
      
    declString: |
      theorem wicks_theorem : (œÜs : List ùìï.FieldOp) ‚Üí ùì£(ofFieldOpList œÜs) =
          ‚àë (œÜsŒõ : WickContraction œÜs.length), œÜsŒõ.wickTerm
        | [] => by
          rw [timeOrder_ofFieldOpList_nil]
          simp only [map_one, List.length_nil, Algebra.smul_mul_assoc]
          rw [sum_WickContraction_nil]
          simp only [wickTerm_empty_nil]
        | œÜ :: œÜs => by
          have ih := wicks_theorem (eraseMaxTimeField œÜ œÜs)
          conv_lhs => rw [timeOrder_eq_maxTimeField_mul_finset, ih, Finset.mul_sum]
          have h1 : œÜ :: œÜs =
              (eraseMaxTimeField œÜ œÜs).insertIdx (maxTimeFieldPosFin œÜ œÜs) (maxTimeField œÜ œÜs) := by
            simp only [eraseMaxTimeField, insertionSortDropMinPos, List.length_cons, Nat.succ_eq_add_one,
              maxTimeField, insertionSortMin, List.get_eq_getElem]
            erw [insertIdx_eraseIdx_fin]
          conv_rhs => rw [wicks_theorem_congr h1]
          conv_rhs => rw [insertLift_sum]
          apply Finset.sum_congr rfl
          intro c _
          rw [Algebra.smul_mul_assoc, mul_wickTerm_eq_sum
            (maxTimeField œÜ œÜs) (eraseMaxTimeField œÜ œÜs) (maxTimeFieldPosFin œÜ œÜs) c]
          trans (1 : ‚ÑÇ) ‚Ä¢ ‚àë k : Option { x // x ‚àà c.uncontracted },
            (c ‚Ü©Œõ (maxTimeField œÜ œÜs) (maxTimeFieldPosFin œÜ œÜs) k).wickTerm
          swap
          ¬∑ simp [uncontractedListGet]
          rw [smul_smul]
          simp only [instCommGroup.eq_1, exchangeSign_mul_self, Nat.succ_eq_add_one,
            Algebra.smul_mul_assoc, Fintype.sum_option, timeContract_insert_none,
            Finset.univ_eq_attach, smul_add, one_smul, uncontractedListGet]
          ¬∑ exact fun k => timeOrder_maxTimeField _ _ k
          ¬∑ exact fun k => lt_maxTimeFieldPosFin_not_timeOrder _ _ k
      termination_by œÜs => œÜs.length
    declNo: "7.15"

  - type: h1
    sectionNo: 8
    content: "Normal-ordered Wick's theorem"

  - type: name
    name: WickContraction.EqTimeOnly.timeOrder_staticContract_of_not_mem
    line: 250
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.TimeCond
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/TimeCond.lean#L250"
    isDef: false
    isThm: false
    docString: |
      Let `œÜs` be a list of `ùìï.FieldOp` and `œÜsŒõ` a `WickContraction` with
      at least one contraction between `ùìï.FieldOp` that do not have the same time. Then
      `ùì£(œÜsŒõ.staticContract.1) = 0`. 
    declString: |
      lemma timeOrder_staticContract_of_not_mem {œÜs : List ùìï.FieldOp} (œÜsŒõ : WickContraction œÜs.length)
          (hl : ¬¨ œÜsŒõ.EqTimeOnly) : ùì£(œÜsŒõ.staticContract.1) = 0 := by
        obtain ‚ü®i, j, hij, œÜsucŒõ, rfl, hr‚ü© := exists_join_singleton_of_not_eqTimeOnly œÜsŒõ hl
        rw [join_staticContract]
        simp only [MulMemClass.coe_mul]
        rw [singleton_staticContract]
        rw [timeOrder_timeOrder_left]
        rw [timeOrder_superCommute_anPart_ofFieldOp_neq_time]
        simp only [zero_mul, map_zero]
        intro h
        simp_all
    declNo: "8.1"

  - type: name
    name: WickContraction.EqTimeOnly.staticContract_eq_timeContract_of_eqTimeOnly
    line: 99
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.TimeCond
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/TimeCond.lean#L99"
    isDef: false
    isThm: false
    docString: |
      Let `œÜs` be a list of `ùìï.FieldOp` and `œÜsŒõ` a `WickContraction` of `œÜs` within
      which every contraction involves two `ùìï.FieldOp`s that have the same time, then
      `œÜsŒõ.staticContract = œÜsŒõ.timeContract`. 
    declString: |
      lemma staticContract_eq_timeContract_of_eqTimeOnly (h : œÜsŒõ.EqTimeOnly) :
          œÜsŒõ.staticContract = œÜsŒõ.timeContract := by
        simp only [staticContract, timeContract]
        apply congrArg
        funext a
        ext
        simp only [List.get_eq_getElem]
        rw [timeContract_of_timeOrderRel]
        apply timeOrderRel_of_eqTimeOnly_pair œÜsŒõ
        rw [‚Üê finset_eq_fstFieldOfContract_sndFieldOfContract]
        exact a.2
        exact h
    declNo: "8.2"

  - type: name
    name: WickContraction.EqTimeOnly.timeOrder_timeContract_mul_of_eqTimeOnly_left
    line: 196
    fileName: PhysLean.QFT.PerturbationTheory.WickContraction.TimeCond
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/WickContraction/TimeCond.lean#L196"
    isDef: false
    isThm: false
    docString: |
      Let `œÜs` be a list of `ùìï.FieldOp`, `œÜsŒõ` a `WickContraction` of `œÜs` within
      which every contraction involves two `ùìï.FieldOp`s that have the same time and
      `b` a general element in `ùìï.FieldOpAlgebra`. Then
      `ùì£(œÜsŒõ.timeContract.1 * b) = œÜsŒõ.timeContract.1 * ùì£(b)`.
      
      This follows from properties of orderings and the ideal defining `ùìï.FieldOpAlgebra`. 
    declString: |
      lemma timeOrder_timeContract_mul_of_eqTimeOnly_left {œÜs : List ùìï.FieldOp}
          (œÜsŒõ : WickContraction œÜs.length)
          (hl : œÜsŒõ.EqTimeOnly) (b : ùìï.FieldOpAlgebra) :
          ùì£(œÜsŒõ.timeContract.1 * b) = œÜsŒõ.timeContract.1 * ùì£(b) := by
        trans ùì£(1 * œÜsŒõ.timeContract.1 * b)
        simp only [one_mul]
        rw [timeOrder_timeContract_mul_of_eqTimeOnly_mid œÜsŒõ hl]
        simp
    declNo: "8.3"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.timeOrder_ofFieldOpList_eqTimeOnly
    line: 23
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.WicksTheoremNormal
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/WicksTheoremNormal.lean#L23"
    isDef: false
    isThm: false
    docString: |
      For a list `œÜs` of `ùìï.FieldOp`, then
      
      `ùì£(œÜs) = ‚àë œÜsŒõ, œÜsŒõ.sign ‚Ä¢ œÜsŒõ.timeContract * ùì£(ùìù([œÜsŒõ]·µò·∂ú))`
      
      where the sum is over all Wick contraction `œÜsŒõ` which only have equal time contractions.
      
      This result follows from
      - `static_wick_theorem` to rewrite `ùì£(œÜs)` on the left hand side as a sum of
        `ùì£(œÜsŒõ.staticWickTerm)`.
      - `EqTimeOnly.timeOrder_staticContract_of_not_mem` and `timeOrder_timeOrder_mid` to set to
        those `ùì£(œÜsŒõ.staticWickTerm)` for which `œÜsŒõ` has a contracted pair which are not
        equal time to zero.
      - `staticContract_eq_timeContract_of_eqTimeOnly` to rewrite the static contract
        in the remaining `ùì£(œÜsŒõ.staticWickTerm)` as a time contract.
      - `timeOrder_timeContract_mul_of_eqTimeOnly_left` to move the time contracts out of the time
        ordering.
      
    declString: |
      lemma timeOrder_ofFieldOpList_eqTimeOnly (œÜs : List ùìï.FieldOp) :
          ùì£(ofFieldOpList œÜs) = ‚àë (œÜsŒõ : {œÜsŒõ // œÜsŒõ.EqTimeOnly (œÜs := œÜs)}),
          œÜsŒõ.1.sign ‚Ä¢ œÜsŒõ.1.timeContract.1 * ùì£(ùìù(ofFieldOpList [œÜsŒõ.1]·µò·∂ú)) := by
        rw [static_wick_theorem œÜs]
        let e2 : WickContraction œÜs.length ‚âÉ
          {œÜsŒõ : WickContraction œÜs.length // œÜsŒõ.EqTimeOnly} ‚äï
          {œÜsŒõ : WickContraction œÜs.length // ¬¨ œÜsŒõ.EqTimeOnly} :=
          (Equiv.sumCompl _).symm
        rw [‚Üê e2.symm.sum_comp]
        simp only [Equiv.symm_symm, Algebra.smul_mul_assoc, Fintype.sum_sum_type,
          Equiv.sumCompl_apply_inl, Equiv.sumCompl_apply_inr, map_add, map_sum, map_smul, e2]
        simp only [staticWickTerm, Algebra.smul_mul_assoc, map_smul]
        conv_lhs =>
          enter [2, 2, x]
          rw [timeOrder_timeOrder_left]
          rw [timeOrder_staticContract_of_not_mem _ x.2]
        simp only [Finset.univ_eq_attach, zero_mul, map_zero, smul_zero, Finset.sum_const_zero, add_zero]
        congr
        funext x
        rw [staticContract_eq_timeContract_of_eqTimeOnly]
        rw [timeOrder_timeContract_mul_of_eqTimeOnly_left]
        exact x.2
        exact x.2
    declNo: "8.4"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.normalOrder_timeOrder_ofFieldOpList_eq_eqTimeOnly_empty
    line: 92
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.WicksTheoremNormal
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/WicksTheoremNormal.lean#L92"
    isDef: false
    isThm: false
    docString: |
      For a list `œÜs` of `ùìï.FieldOp`, then
      
      `ùì£(ùìù(œÜs)) = ùì£(œÜs) - ‚àë œÜsŒõ, œÜsŒõ.sign ‚Ä¢ œÜsŒõ.timeContract.1 * ùì£(ùìù([œÜsŒõ]·µò·∂ú))`
      
      where the sum is over all *non-empty* Wick contraction `œÜsŒõ` which only
        have equal time contractions.
      
      This result follows directly from
      - `timeOrder_ofFieldOpList_eqTimeOnly`
      
    declString: |
      lemma normalOrder_timeOrder_ofFieldOpList_eq_eqTimeOnly_empty (œÜs : List ùìï.FieldOp) :
          ùì£(ùìù(ofFieldOpList œÜs)) = ùì£(ofFieldOpList œÜs) -
          ‚àë (œÜsŒõ : {œÜsŒõ // œÜsŒõ.EqTimeOnly (œÜs := œÜs) ‚àß œÜsŒõ ‚â† empty}),
          œÜsŒõ.1.sign ‚Ä¢ œÜsŒõ.1.timeContract.1 * ùì£(ùìù(ofFieldOpList [œÜsŒõ.1]·µò·∂ú)) := by
        rw [timeOrder_ofFieldOpList_eq_eqTimeOnly_empty]
        simp
    declNo: "8.5"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.timeOrder_haveEqTime_split
    line: 110
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.WicksTheoremNormal
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/WicksTheoremNormal.lean#L110"
    isDef: false
    isThm: false
    docString: |
      For a list `œÜs` of `ùìï.FieldOp`, then `ùì£(œÜs)` is equal to the sum of
      
      - `‚àë œÜsŒõ, œÜsŒõ.wickTerm` where the sum is over all Wick contraction `œÜsŒõ` which have
        no contractions of equal time.
      - `‚àë œÜsŒõ, œÜsŒõ.sign ‚Ä¢ œÜsŒõ.timeContract * (‚àë œÜssucŒõ, œÜssucŒõ.wickTerm)`, where
        the first sum is over all Wick contraction `œÜsŒõ` which only have equal time contractions
        and the second sum is over all Wick contraction `œÜssucŒõ` of the uncontracted elements of `œÜsŒõ`
        which do not have any equal time contractions.
      
      The proof proceeds as follows
      - `wicks_theorem` is used to rewrite `ùì£(œÜs)` as a sum over all Wick contractions.
      - The sum over all Wick contractions is then split additively into two parts based on having
        or not having an equal time contractions.
      - Using `join`, the sum `‚àë œÜsŒõ, _` over Wick contractions which do have equal time contractions
        is split into two sums `‚àë œÜsŒõ, ‚àë œÜsucŒõ, _`, the first over non-zero elements
        which only have equal time contractions and the second over Wick contractions `œÜsucŒõ` of
        `[œÜsŒõ]·µò·∂ú` which do not have equal time contractions.
      - `join_sign_timeContract` is then used to equate terms.
      
    declString: |
      lemma timeOrder_haveEqTime_split (œÜs : List ùìï.FieldOp) :
          ùì£(ofFieldOpList œÜs) = (‚àë (œÜsŒõ : {œÜsŒõ : WickContraction œÜs.length // ¬¨ HaveEqTime œÜsŒõ}),
          œÜsŒõ.1.sign ‚Ä¢ œÜsŒõ.1.timeContract.1 * ùìù(ofFieldOpList [œÜsŒõ.1]·µò·∂ú))
          + ‚àë (œÜsŒõ : {œÜsŒõ // œÜsŒõ.EqTimeOnly (œÜs := œÜs) ‚àß œÜsŒõ ‚â† empty}), œÜsŒõ.1.sign ‚Ä¢ œÜsŒõ.1.timeContract *
          (‚àë œÜssucŒõ : { œÜssucŒõ : WickContraction [œÜsŒõ.1]·µò·∂ú.length // ¬¨ œÜssucŒõ.HaveEqTime },
            œÜssucŒõ.1.wickTerm) := by
        rw [wicks_theorem]
        simp only [wickTerm]
        let e1 : WickContraction œÜs.length ‚âÉ {œÜsŒõ // HaveEqTime œÜsŒõ} ‚äï {œÜsŒõ // ¬¨ HaveEqTime œÜsŒõ} := by
          exact (Equiv.sumCompl HaveEqTime).symm
        rw [‚Üê e1.symm.sum_comp]
        simp only [Equiv.symm_symm, Algebra.smul_mul_assoc, Fintype.sum_sum_type,
          Equiv.sumCompl_apply_inl, Equiv.sumCompl_apply_inr, ne_eq, sub_left_inj, e1]
        rw [add_comm]
        congr 1
        let f : WickContraction œÜs.length ‚Üí ùìï.FieldOpAlgebra := fun œÜsŒõ =>
          œÜsŒõ.sign ‚Ä¢ (œÜsŒõ.timeContract.1 * ùìù(ofFieldOpList [œÜsŒõ]·µò·∂ú))
        change ‚àë (œÜsŒõ : {œÜsŒõ : WickContraction œÜs.length // HaveEqTime œÜsŒõ}), f œÜsŒõ.1 = _
        rw [sum_haveEqTime]
        congr
        funext œÜsŒõ
        simp only [f]
        conv_lhs =>
          enter [2, œÜsucŒõ]
          rw [‚Üê Algebra.smul_mul_assoc]
          rw [join_sign_timeContract œÜsŒõ.1 œÜsucŒõ.1]
        conv_lhs =>
          enter [2, œÜsucŒõ]
          rw [mul_assoc]
        rw [‚Üê Finset.mul_sum, ‚Üê Algebra.smul_mul_assoc]
        congr
        funext œÜsŒõ'
        simp only [ne_eq, Algebra.smul_mul_assoc]
        congr 1
        rw [@join_uncontractedListGet]
    declNo: "8.6"

  - type: name
    name: FieldSpecification.FieldOpAlgebra.wicks_theorem_normal_order
    line: 218
    fileName: PhysLean.QFT.PerturbationTheory.FieldOpAlgebra.WicksTheoremNormal
    status: "complete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/QFT/PerturbationTheory/FieldOpAlgebra/WicksTheoremNormal.lean#L218"
    isDef: false
    isThm: true
    docString: |
      For a list `œÜs` of `ùìï.FieldOp`, the normal-ordered version of Wick's theorem states that
      
      `ùì£(ùìù(œÜs)) = ‚àë œÜsŒõ, œÜsŒõ.wickTerm`
      
      where the sum is over all Wick contraction `œÜsŒõ` in which no two contracted elements
      have the same time.
      
      The proof proceeds by induction on `œÜs`, with the base case `[]` holding by following
      through definitions. and the inductive case holding as a result of
      - `timeOrder_haveEqTime_split`
      - `normalOrder_timeOrder_ofFieldOpList_eq_eqTimeOnly_empty`
      - and the induction hypothesis on `ùì£(ùìù([œÜsŒõ.1]·µò·∂ú))` for contractions `œÜsŒõ` of `œÜs` which only
        have equal time contractions and are non-empty.
      
    declString: |
      theorem wicks_theorem_normal_order : (œÜs : List ùìï.FieldOp) ‚Üí
          ùì£(ùìù(ofFieldOpList œÜs)) =
          ‚àë (œÜsŒõ : {œÜsŒõ : WickContraction œÜs.length // ¬¨ HaveEqTime œÜsŒõ}), œÜsŒõ.1.wickTerm
        | [] => wicks_theorem_normal_order_empty
        | œÜ :: œÜs => by
          rw [normalOrder_timeOrder_ofFieldOpList_eq_not_haveEqTime_sub_inductive]
          simp only [Algebra.smul_mul_assoc, ne_eq, add_right_eq_self]
          apply Finset.sum_eq_zero
          intro œÜsŒõ hœÜsŒõ
          simp only [smul_eq_zero]
          right
          have ih := wicks_theorem_normal_order [œÜsŒõ.1]·µò·∂ú
          rw [ih]
          simp [wickTerm]
      termination_by œÜs => œÜs.length
      decreasing_by
        simp only [uncontractedListGet, List.length_cons, List.length_map, gt_iff_lt]
        rw [uncontractedList_length_eq_card]
        have hc := uncontracted_card_eq_iff œÜsŒõ.1
        simp only [List.length_cons, œÜsŒõ.2.2, iff_false] at hc
        have hc' := uncontracted_card_le œÜsŒõ.1
        simp_all only [Algebra.smul_mul_assoc, List.length_cons, Finset.mem_univ, gt_iff_lt]
        omega
    declNo: "8.7"