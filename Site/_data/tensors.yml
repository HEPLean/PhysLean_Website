
title: "Tensors and index notation ðŸš§"
curators: Joseph Tooby-Smith
parts:
  
  - type: warning
    content: "This note is a work in progress. (5th March 2025)"

  - type: h1
    sectionNo: 1
    content: "Introduction"

  - type: p
    content: "This note is related to: https://arxiv.org/pdf/2411.07667, and concerns the
      implmentation of tensors and index notation into PhysLean, and
      its mathematical structure."

  - type: p
    content: "This note is not intended to be a first-introduction to tensors and index notation."

  - type: h1
    sectionNo: 2
    content: "Tensor Species"

  - type: name
    name: TensorSpecies
    line: 23
    fileName: PhysLean.Relativity.Tensors.TensorSpecies.Basic
    status: "incomplete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/Relativity/Tensors/TensorSpecies/Basic.lean#L23"
    isDef: true
    isThm: false
    docString: |
      The structure `TensorSpecies` contains the necessary structure needed to define
      a system of tensors with index notation. Examples of `TensorSpecies` include real Lorentz tensors,
      complex Lorentz tensors, and ordinary Euclidean tensors.
    declString: |
      structure TensorSpecies where
        /-- The commutative ring over which we want to consider the tensors to live in,
          usually `â„` or `â„‚`. -/
        k : Type
        /-- An instance of `k` as a commutative ring. -/
        k_commRing : CommRing k
        /-- The symmetry group acting on these tensor e.g. the Lorentz group or SL(2,â„‚). -/
        G : Type
        /-- An instance of `G` as a group. -/
        G_group : Group G
        /-- The colors of indices e.g. up or down. -/
        C : Type
        /-- A functor from `C` to `Rep k G` giving our building block representations.
          Equivalently a function `C â†’ Re k G`. -/
        FD : Discrete C â¥¤ Rep k G
        /-- A specification of the dimension of each color in C. This will be used for explicit
          evaluation of tensors. -/
        repDim : C â†’ â„•
        /-- repDim is not zero for any color. This allows casting of `â„•` to `Fin (S.repDim c)`. -/
        repDim_neZero (c : C) : NeZero (repDim c)
        /-- A basis for each Module, determined by the evaluation map. -/
        basis : (c : C) â†’ Basis (Fin (repDim c)) k (FD.obj (Discrete.mk c)).V
        /-- A map from `C` to `C`. An involution. -/
        Ï„ : C â†’ C
        /-- The condition that `Ï„` is an involution. -/
        Ï„_involution : Function.Involutive Ï„
        /-- The natural transformation describing contraction. -/
        contr : OverColor.Discrete.pairÏ„ FD Ï„ âŸ¶ ðŸ™_ (Discrete C â¥¤ Rep k G)
        /-- Contraction is symmetric with respect to duals. -/
        contr_tmul_symm (c : C) (x : FD.obj (Discrete.mk c))
            (y : FD.obj (Discrete.mk (Ï„ c))) :
          (contr.app (Discrete.mk c)).hom (x âŠ—â‚œ[k] y) = (contr.app (Discrete.mk (Ï„ c))).hom
          (y âŠ—â‚œ (FD.map (Discrete.eqToHom (Ï„_involution c).symm)).hom x)
        /-- The natural transformation describing the unit. -/
        unit : ðŸ™_ (Discrete C â¥¤ Rep k G) âŸ¶ OverColor.Discrete.Ï„Pair FD Ï„
        /-- The unit is symmetric. -/
        unit_symm (c : C) :
          ((unit.app (Discrete.mk c)).hom (1 : k)) =
          ((FD.obj (Discrete.mk (Ï„ (c)))) â—
            (FD.map (Discrete.eqToHom (Ï„_involution c)))).hom
          ((Î²_ (FD.obj (Discrete.mk (Ï„ (Ï„ c)))) (FD.obj (Discrete.mk (Ï„ (c))))).hom.hom
          ((unit.app (Discrete.mk (Ï„ c))).hom (1 : k)))
        /-- Contraction with unit leaves invariant. -/
        contr_unit (c : C) (x : FD.obj (Discrete.mk (c))) :
          (Î»_ (FD.obj (Discrete.mk (c)))).hom.hom
          (((contr.app (Discrete.mk c)) â–· (FD.obj (Discrete.mk (c)))).hom
          ((Î±_ _ _ (FD.obj (Discrete.mk (c)))).inv.hom
          (x âŠ—â‚œ[k] (unit.app (Discrete.mk c)).hom (1 : k)))) = x
        /-- The natural transformation describing the metric. -/
        metric : ðŸ™_ (Discrete C â¥¤ Rep k G) âŸ¶ OverColor.Discrete.pair FD
        /-- On contracting metrics we get back the unit. -/
        contr_metric (c : C) :
          (Î²_ (FD.obj (Discrete.mk c)) (FD.obj (Discrete.mk (Ï„ c)))).hom.hom
          (((FD.obj (Discrete.mk c)) â— (Î»_ (FD.obj (Discrete.mk (Ï„ c)))).hom).hom
          (((FD.obj (Discrete.mk c)) â— ((contr.app (Discrete.mk c)) â–·
          (FD.obj (Discrete.mk (Ï„ c))))).hom
          (((FD.obj (Discrete.mk c)) â— (Î±_ (FD.obj (Discrete.mk (c)))
            (FD.obj (Discrete.mk (Ï„ c))) (FD.obj (Discrete.mk (Ï„ c)))).inv).hom
          ((Î±_ (FD.obj (Discrete.mk (c))) (FD.obj (Discrete.mk (c)))
            (FD.obj (Discrete.mk (Ï„ c)) âŠ— FD.obj (Discrete.mk (Ï„ c)))).hom.hom
          ((metric.app (Discrete.mk c)).hom (1 : k) âŠ—â‚œ[k]
            (metric.app (Discrete.mk (Ï„ c))).hom (1 : k))))))
          = (unit.app (Discrete.mk c)).hom (1 : k)
    declNo: "2.1"

  - type: h2
    sectionNo: "2.1"
    content: "Example: Complex Lorentz tensors"

  - type: h1
    sectionNo: 3
    content: "Tensor trees"

  - type: name
    name: TensorTree
    line: 30
    fileName: PhysLean.Relativity.Tensors.Tree.Basic
    status: "incomplete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/Relativity/Tensors/Tree/Basic.lean#L30"
    isDef: true
    isThm: false
    docString: |
      A syntax tree for tensor expressions. 
    declString: |
      inductive TensorTree (S : TensorSpecies) : {n : â„•} â†’ (Fin n â†’ S.C) â†’ Type where
        /-- A general tensor node. -/
        | tensorNode {n : â„•} {c : Fin n â†’ S.C} (T : S.F.obj (OverColor.mk c)) : TensorTree S c
        /-- A node corresponding to the scalar multiple of a tensor by a element of the field. -/
        | smul {n : â„•} {c : Fin n â†’ S.C} : S.k â†’ TensorTree S c â†’ TensorTree S c
        /-- A node corresponding to negation of a tensor. -/
        | neg {n : â„•} {c : Fin n â†’ S.C} : TensorTree S c â†’ TensorTree S c
        /-- A node corresponding to the addition of two tensors. -/
        | add {n : â„•} {c : Fin n â†’ S.C} : TensorTree S c â†’ TensorTree S c â†’ TensorTree S c
        /-- A node corresponding to the action of a group element on a tensor. -/
        | action {n : â„•} {c : Fin n â†’ S.C} : S.G â†’ TensorTree S c â†’ TensorTree S c
        /-- A node corresponding to the permutation of indices of a tensor. -/
        | perm {n m : â„•} {c : Fin n â†’ S.C} {c1 : Fin m â†’ S.C}
            (Ïƒ : (OverColor.mk c) âŸ¶ (OverColor.mk c1)) (t : TensorTree S c) : TensorTree S c1
        /-- A node corresponding to the product of two tensors. -/
        | prod {n m : â„•} {c : Fin n â†’ S.C} {c1 : Fin m â†’ S.C}
          (t : TensorTree S c) (t1 : TensorTree S c1) : TensorTree S (Sum.elim c c1 âˆ˜ finSumFinEquiv.symm)
        /-- A node corresponding to the contraction of indices of a tensor. -/
        | contr {n : â„•} {c : Fin n.succ.succ â†’ S.C} : (i : Fin n.succ.succ) â†’
          (j : Fin n.succ) â†’ (h : c (i.succAbove j) = S.Ï„ (c i)) â†’ TensorTree S c â†’
          TensorTree S (c âˆ˜ i.succAbove âˆ˜ j.succAbove)
        /-- A node corresponding to the evaluation of an index of a tensor. -/
        | eval {n : â„•} {c : Fin n.succ â†’ S.C} : (i : Fin n.succ) â†’ (x : â„•) â†’ TensorTree S c â†’
          TensorTree S (c âˆ˜ i.succAbove)
    declNo: "3.1"

  - type: name
    name: TensorTree.tensor
    line: 152
    fileName: PhysLean.Relativity.Tensors.Tree.Basic
    status: "incomplete"
    link: "https://github.com/HEPLean/PhysLean/blob/master/PhysLean/Relativity/Tensors/Tree/Basic.lean#L152"
    isDef: true
    isThm: false
    docString: |
      The underlying tensor a tensor tree corresponds to. 
    declString: |
      def tensor {n : â„•} {c : Fin n â†’ S.C} : TensorTree S c â†’ S.F.obj (OverColor.mk c) := fun
        | tensorNode t => t
        | smul a t => a â€¢ t.tensor
        | neg t => - t.tensor
        | add t1 t2 => t1.tensor + t2.tensor
        | action g t => (S.F.obj (OverColor.mk _)).Ï g t.tensor
        | perm Ïƒ t => (S.F.map Ïƒ).hom t.tensor
        | prod t1 t2 => (S.F.map (OverColor.equivToIso finSumFinEquiv).hom).hom
          ((Functor.LaxMonoidal.Î¼ S.F _ _).hom (t1.tensor âŠ—â‚œ t2.tensor))
        | contr i j h t => (S.contrMap _ i j h).hom t.tensor
        | eval i e t => (S.evalMap i (Fin.ofNat' _ e)) t.tensor
    declNo: "3.2"

  - type: h2
    sectionNo: "3.1"
    content: "Node identities"

  - type: h1
    sectionNo: 4
    content: "Elaboration"

  - type: h1
    sectionNo: 5
    content: "Example use: Pauli matrices"